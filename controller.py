#  a part of browseRDF (http://www.github.com/kdbanman/browseRDF)
#
# copyright (c) 2013 all rights reserved, Kirby Banman
#
# this code is subject to the GPLv3 license.

from tulip import *

import rdflib

class Controller():
  '''
  class for managing data flow between view and model with a tulip graph and a
  PyQt toolbar
  '''
  # container for both aggregate and frontier graphs
  _parent = tlp.newGraph()
  _aggregate = _parent.addSubGraph()

  # layout property for nice display
  viewLayout = _parent.getLayoutProperty("viewLayout")
  # shape will differentiate between uris and literals
  viewShape = _parent.getIntegerProperty("viewShape")

  # selection property to observe for exploration/saving
  viewSelection = _parent.getBooleanProperty("viewSelection")
  # each node needs to know its uri or literal, and which one of those it is
  content = _parent.getStringProperty("content")
  uriLiteral = _parent.getStringProperty("uriLiteral")


  #TODO: member function addToAggregate(uris)
  #  '''
  #  adds the passed tulip graph, generated by shortest path to root from
  #  selected node(s), to the aggregate
  #  '''



  # for a specific node in the _parent graph, the next 3 functions get the 
  # properties of that node
  def getContent(self, node):
    try:
      return self.content[node]
    except:
      print "node not in graph"
      quit()

  def isLiteral(self, node):
    try:
      if self.uriLiteral[node] == "URI":
        return False
      elif self.uriLiteral[node] == "Literal":
        return True
      else:
        print "node does not have uriLiteral property"
        quit()
    except:
      print "node not in graph"
      quit()

  def isURI(self, node):
    return not self.isLiteral(node)
  


  def triplesToTulip(self, rdflibGraph):
    '''
    converts an rdflib.Graph() of triples into a Tulip (sub)graph for display
    by the view class.  the uri exploration path of the graph is known by the
    graph so that shortest path to aggregate can be calculated.
    '''
    frontGraph = self._parent.addSubGraph()
    
    # iterate through passed graph to build tulip graph
    for s,p,o in rdflibGraph:
      sContent = s.encode("UTF-8")
      oContent = o.encode("UTF-8")

      # check if node is already in graph
      # OPTIMIZATION:  This could use a hash to make the membership check constant time
      newS = True
      newO = True
      for n in frontGraph.getNodes():
        nContent = self.content[n]
        if nContent == sContent:
          sNode = n
          newS = False
        if nContent == oContent:
          oNode = n
          newO = False
      
      # add nodes to subgraph if they are not new
      if newS:
        sNode = frontGraph.addNode()
        self.content[sNode] = sContent
        if type(s) == rdflib.URIRef:
          self.uriLiteral[sNode] = "URI"
        else:
          self.uriLiteral[sNode] = "Literal"

      if newO:
        oNode = frontGraph.addNode()
        self.content[oNode] = oContent
        if type(o) == rdflib.URIRef:
          self.uriLiteral[oNode] = "URI"
        else:
          self.uriLiteral[oNode] = "Literal"
       
      # connect the nodes by their predicate
      pEdge = frontGraph.addEdge(sNode, oNode)
      self.content[pEdge] = p.encode("UTF-8")
      
    self.forceLayout(frontGraph)

    return frontGraph


  def forceLayout(self, graph):
    params = tlp.getDefaultPluginParameters("FM^3 (OGDF)", graph)
    graph.applyLayoutAlgorithm("FM^3 (OGDF)", self.viewLayout, params)

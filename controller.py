#  a part of browseRDF (http://www.github.com/kdbanman/browseRDF)
#
# copyright (c) 2013 all rights reserved, Kirby Banman
#
# this code is subject to the GPLv3 license.

from tulip import *
from tulipogl import *
from tulipgui import *

from PyQt.QtCore import *

import rdflib

class Model():
  '''
  class for retrieving new rdf, maintaining browsing history, and serializing
  aggregated graphs
  '''
  
  # class variable for browser's data history
  _history = rdflib.Graph()

  def getGraph(self, uri):
    '''
    checks that a uri returns rdf, adds the data to history, and returns
    the document as an rdflib graph
    '''
    subGraph = rdflib.Graph()
    try:
      subGraph.load(uri)
    except:
      print "the following uri did not return a valid rdf document:"
      print uri
      return -1

    self._history.add(subGraph)

    return subGraph
    
  def serialize(self, uris):
    '''
    looks through the entire browsing history for all uris, builds a graph
    containing them and all of their predicates, and serializes it as rdf-xml.
    prints an error to terminal if a uri is not found in the history.
    '''
    #TODO: for uri in list, query for triples with all other uris ( O(n^2) )

class Controller():
  '''
  class for managing data flow between view and model with a tulip graph and a
  PyQt toolbar
  '''
  # container for both aggregate and frontier graphs
  _parent = tlp.newGraph()
  _aggregate = _parent.addSubGraph()
  # each node needs to know its uri or literal, and which it is
  content = _parent.getStringProperty("content")
  uriLiteral = _parent.getStringProperty("uriLiteral")

  #TODO: SelectionObserver class that looks at the state of the toolbar 
  #      and behaves accordingly

  #TODO: Toolbar class for changing interaction modes

  #TODO: member function addToAggregate(uris)
    '''
    adds the passed tulip graph, generated by shortest path to root from
    selected node(s), to the aggregate
    '''

  def triplesToTulip(rdflibGraph):
    '''
    converts an rdflib.Graph() of triples into a Tulip (sub)graph for display
    by the view class.  the uri exploration path of the graph is known by the
    graph so that shortest path to aggregate can be calculated.
    '''
    frontGraph = _parent.addSubGraph() #TODO: do content and uriLiteral properties trickle down?
    
    # iterate through passed graph to build tulip graph
    for s,p,o in rdfGraph:
      sContent = s.encode("UTF-8")
      oContent = o.encode("UTF-8")

      # check if node is already in graph
      newS = True
      newO = True
      for n in frontGraph.getNodes():
        nContent = content[n]
        if nContent == sContent:
          sNode = n
          newS = False
        if nContent == oContent:
          oNode = n
          newO = False
      
      # add nodes to subgraph if they are not new
      if newS:
        sNode = frontGraph.addNode()
        content[sNode] = sContent
        if type(s) == rdflib.URIRef:
          uriLiteral[sNode] = "URI"
        else:
          uriLiteral[sNode] = "Literal"

      if newO:
        oNode = graph.addNode()
        content[oNode] = oContent
        if type(o) == rdflib.URIRef:
          uriLiteral[oNode] = "URI"
        else:
          uriLiteral[oNode] = "Literal"
       
      # connect the nodes by their predicate
      pEdge = frontGraph.addEdge(sNode, oNode)
      content[pEdge] = p.encode("UTF-8")
      
    #TODO: FrontierGraph class that knows its exploration path

class View():
  '''
  class for managing frontier windows and aggregate graph window.
  '''
  
  #TODO: newFrontier(tulipGraph)
  '''
  a function that creates a new window with the contents of a freshly
  dereferenced uri.
  '''

  #TODO: makePretty(graph, window)
  '''
  function that applies a force-directed layout algorithm, a degree-based
  sizing algorithm, and updates the view of the graph.
  '''

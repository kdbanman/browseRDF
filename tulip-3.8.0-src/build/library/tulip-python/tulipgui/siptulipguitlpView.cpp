/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Fri Apr 26 16:36:19 2013
 */

#include "sipAPItulipgui.h"

#line 31 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
#include <tulip/View.h>
#line 12 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

#line 29 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/..//tulip-ogl/../tulip/../stl/string.sip"
	// Include the library interface to the type being mapped.
#include <string>
#line 17 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/..//tulip-ogl/../tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/..//tulip-ogl/../tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/..//tulip-ogl/../tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 112 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/..//tulip-ogl/../tulip/Graph.sip"
#include <tulip/Graph.h>
#line 34 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"


PyDoc_STRVAR(doc_tlp_View_setData, "tlp.View.setData(graph, dataSet)\n"
    "\n"
    "Sets the graph and parameters for the view.\n"
    "\n"
    ":param graph: the graph from which the view will be drawn.\n"
    ":type graph: :class:`tulip.tlp.Graph`\n"
    ":param dataSet: the view parameters\n"
    ":type dataSet: :class:`tulip.tlp.DataSet`");

extern "C" {static PyObject *meth_tlp_View_setData(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_setData(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::Graph * a0;
        tlp::DataSet * a1;
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J9", &sipSelf, sipType_tlp_View, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_DataSet, &a1))
        {
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_View, sipName_setData);
                return NULL;
            }

#line 68 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    tlp::MainController *mainController = dynamic_cast<tlp::MainController *>(tlp::Controller::getCurrentController());
    if (mainController) {
        if (!sipCpp->getGraph()->getRoot()->isDescendantGraph(a0) && a0 != sipCpp->getGraph()->getRoot()) {
            sipIsErr = 1;
            std::ostringstream oss;
            oss << "Error : the graph you are trying to set on a view does not belong to the same sub-graphs hierarchy as the one currently loaded." << std::endl;
            oss << "<graph " << a0->getName() << " (id " << a0->getId() << ")>";
            oss << "is not a descendant of <graph " << sipCpp->getGraph()->getName() << " (id " << sipCpp->getGraph()->getId() << ")>";
            PyErr_SetString(PyExc_Exception, oss.str().c_str());
         } else {
            mainController->setDataOfView(sipCpp, a0, *a1);
         }
    } else {
        sipCpp->setData(a0, *a1);
    }
#line 83 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_setData, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_setGraph, "tlp.View.setGraph(graph)\n"
    "\n"
    "Sets the graph for the view. The current parameters will be kept.\n"
    "\n"
    ":param graph: the graph from which the view will be drawn.\n"
    ":type graph: :class:`tulip.tlp.Graph`");

extern "C" {static PyObject *meth_tlp_View_setGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_setGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::Graph * a0;
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_View, &sipCpp, sipType_tlp_Graph, &a0))
        {
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_View, sipName_setGraph);
                return NULL;
            }

#line 98 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    tlp::MainController *mainController = dynamic_cast<tlp::MainController *>(tlp::Controller::getCurrentController());
    if (mainController) {
        if (!sipCpp->getGraph()->getRoot()->isDescendantGraph(a0) && a0 != sipCpp->getGraph()->getRoot()) {
            sipIsErr = 1;
            std::ostringstream oss;
            oss << "Error : the graph you are trying to set on a view does not belong to the same sub-graphs hierarchy as the one currently loaded." << std::endl;
            oss << "<graph " << a0->getName() << " (id " << a0->getId() << ")>";
            oss << "is not a descendant of <graph " << sipCpp->getGraph()->getName() << " (id " << sipCpp->getGraph()->getId() << ")>";
            PyErr_SetString(PyExc_Exception, oss.str().c_str());
        } else {
            mainController->setGraphOfView(sipCpp, a0);
        }
    } else {
        sipCpp->setGraph(a0);
    }
#line 143 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_setGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_getData, "tlp.View.getData()\n"
    "\n"
    "Returns the current parameters of the view.\n"
    "\n"
    ":rtype: :class:`tulip.tlp.DataSet`");

extern "C" {static PyObject *meth_tlp_View_getData(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_getData(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_View, &sipCpp))
        {
            tlp::DataSet *sipRes = 0;

#line 127 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    tlp::Graph *g = NULL;
    tlp::DataSet data;
    sipCpp->getData(&g, &data);
    sipRes = new tlp::DataSet(data);
#line 183 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            return sipConvertFromNewType(sipRes,sipType_tlp_DataSet,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_getData, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_getGraph, "tlp.View.getGraph()\n"
    "\n"
    "Returns the graph currently attached to the view.\n"
    "\n"
    ":rtype: :class:`tulip.tlp.Graph`");

extern "C" {static PyObject *meth_tlp_View_getGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_getGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_View, &sipCpp))
        {
            tlp::Graph *sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_View, sipName_getGraph);
                return NULL;
            }

            sipRes = sipCpp->getGraph();

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_getGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_savePicture, "tlp.View.savePicture(picturePath, width, height, center)\n"
    "\n"
    "Takes a snapshot of the view (if the view supports it), and saves it to a picture on disk.\n"
    "Returns :const:`True` if the operation succeeds.\n"
    "\n"
    ":param picturePath: the absolute path of the picture file with extension (used to infer image type)\n"
    ":type picturePath: string\n"
    ":param width: the picture width\n"
    ":type width: integer\n"
    ":param height: the picture height\n"
    ":type height: integer\n"
    ":param center: if :const:`True`, center the view before taking the snapshot, otherwise use the current zoom and pan level\n"
    ":type center: boolean\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_View_savePicture(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_savePicture(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const std::string * a0;
        int a0State = 0;
        int a1;
        int a2;
        bool a3;
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1iib", &sipSelf, sipType_tlp_View, &sipCpp, sipType_std_string,&a0, &a0State, &a1, &a2, &a3))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->tlp::View::savePicture(*a0,a1,a2,a3) : sipCpp->savePicture(*a0,a1,a2,a3));
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_savePicture, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_draw, "tlp.View.draw()\n"
    "\n"
    "Draws/Updates the view.");

extern "C" {static PyObject *meth_tlp_View_draw(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_draw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_View, &sipCpp))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_View, sipName_draw);
                return NULL;
            }

#line 174 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    sipCpp->draw();
    tlp::MainController *mainController = dynamic_cast<tlp::MainController *>(tlp::Controller::getCurrentController());
    if (!mainController) {
        QApplication::processEvents();
    }
#line 308 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_draw, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_getName, "tlp.View.getName()\n"
    "\n"
    "Returns the name of the view.\n"
    "\n"
    ":rtype: string");

extern "C" {static PyObject *meth_tlp_View_getName(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_View, &sipCpp))
        {
            std::string *sipRes = 0;

#line 193 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    sipRes = new std::string(tvm.getNameOfView(sipCpp));
#line 342 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_getName, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_setVisible, "tlp.View.setVisible(visible)\n"
    "\n"
    "Hides / Shows the view window. That method has effects only when working trough the\n"
    "classical Python interpreter. It can be usefull for scripts that only needs.\n"
    "to save visualizations snaphots to disk. View windows can be hidden and the script will\n"
    "terminate directly instead of waiting for the views windows to be closed by the user.\n"
    "However, the view window needs to be displayed at least once in order to correctly\n"
    "initialize the OpenGL context.\n"
    "\n"
    ":param visible: the state of the view window visibility\n"
    ":type visible: boolean\n"
    "");

extern "C" {static PyObject *meth_tlp_View_setVisible(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_setVisible(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0;
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_tlp_View, &sipCpp, &a0))
        {
#line 215 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    tvm.setViewVisible(sipCpp, a0);
#line 381 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_setVisible, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_resize, "tlp.View.resize(width, height)\n"
    "\n"
    "Resizes the view windows. That method has effects only when working trough the\n"
    "classical Python interpreter.\n"
    "\n"
    ":param width: the new width of the view window\n"
    ":type width: integer\n"
    ":param height: the new height of the view window\n"
    ":type height: integer");

extern "C" {static PyObject *meth_tlp_View_resize(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_resize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        int a1;
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bii", &sipSelf, sipType_tlp_View, &sipCpp, &a0, &a1))
        {
#line 234 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    tvm.resizeView(sipCpp, a0, a1);
#line 419 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_resize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_setPos, "tlp.View.setPos(x, y)\n"
    "\n"
    "Set the position on screen of the view windows. That method has effects only when working trough the\n"
    "classical Python interpreter.\n"
    "\n"
    ":param x: the new x position of the view window\n"
    ":type x: integer\n"
    ":param y: the new y position of the view window\n"
    ":type y: integer");

extern "C" {static PyObject *meth_tlp_View_setPos(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_setPos(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        int a1;
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bii", &sipSelf, sipType_tlp_View, &sipCpp, &a0, &a1))
        {
#line 253 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    tvm.setViewPos(sipCpp, a0, a1);
#line 457 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_setPos, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_View_setOptionsWidgetsVisible, "tlp.View.setOptionsWidgetsVisible(visible)\n"
    "\n"
    "Shows / hides the options widgets located on the left side of the view.\n"
    "That method has effects only when working trough the\n"
    "classical Python interpreter.\n"
    "\n"
    ":param visible: the state of the options widgets visibility\n"
    ":type visible: boolean");

extern "C" {static PyObject *meth_tlp_View_setOptionsWidgetsVisible(PyObject *, PyObject *);}
static PyObject *meth_tlp_View_setOptionsWidgetsVisible(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0;
        tlp::View *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_tlp_View, &sipCpp, &a0))
        {
#line 271 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulipgui/View.sip"
    tvm.setViewOptionsWidgetsVisible(sipCpp, a0);
#line 493 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulipgui/siptulipguitlpView.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_View, sipName_setOptionsWidgetsVisible, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_tlp_View(void *, const sipTypeDef *);}
static void *cast_tlp_View(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_tlp_View)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_tlp_View(void *, int);}
static void release_tlp_View(void *sipCppV,int)
{
    delete reinterpret_cast<tlp::View *>(sipCppV);
}


extern "C" {static void dealloc_tlp_View(sipSimpleWrapper *);}
static void dealloc_tlp_View(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_tlp_View(sipGetAddress(sipSelf),0);
    }
}


static PyMethodDef methods_tlp_View[] = {
    {SIP_MLNAME_CAST(sipName_draw), meth_tlp_View_draw, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_draw)},
    {SIP_MLNAME_CAST(sipName_getData), meth_tlp_View_getData, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_getData)},
    {SIP_MLNAME_CAST(sipName_getGraph), meth_tlp_View_getGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_getGraph)},
    {SIP_MLNAME_CAST(sipName_getName), meth_tlp_View_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_getName)},
    {SIP_MLNAME_CAST(sipName_resize), meth_tlp_View_resize, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_resize)},
    {SIP_MLNAME_CAST(sipName_savePicture), meth_tlp_View_savePicture, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_savePicture)},
    {SIP_MLNAME_CAST(sipName_setData), meth_tlp_View_setData, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_setData)},
    {SIP_MLNAME_CAST(sipName_setGraph), meth_tlp_View_setGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_setGraph)},
    {SIP_MLNAME_CAST(sipName_setOptionsWidgetsVisible), meth_tlp_View_setOptionsWidgetsVisible, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_setOptionsWidgetsVisible)},
    {SIP_MLNAME_CAST(sipName_setPos), meth_tlp_View_setPos, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_setPos)},
    {SIP_MLNAME_CAST(sipName_setVisible), meth_tlp_View_setVisible, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_View_setVisible)}
};

PyDoc_STRVAR(doc_tlp_View, ".. versionadded:: 3.8\n"
    "\n"
    "This is the base class for Tulip data views. Use the following functions to get instances on such object :\n"
    "\n"
    "    * :func:`tlp.addView`\n"
    "    * :func:`tlp.getOpenedViews`\n"
    "    * :func:`tlp.getViewsOfGraph`\n"
    "");


sipClassTypeDef sipTypeDef_tulipgui_tlp_View = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_tlp__View,
        {0}
    },
    {
        sipNameNr_View,
        {1, 255, 0},
        11, methods_tlp_View,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_tlp_View,
    -1,
    -1,
    0,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_tlp_View,
    0,
    0,
    0,
    release_tlp_View,
    cast_tlp_View,
    0,
    0,
    0
};

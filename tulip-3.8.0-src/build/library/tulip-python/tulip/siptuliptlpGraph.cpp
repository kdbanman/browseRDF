/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Mon Apr 29 01:46:10 2013
 */

#include "sipAPItulip.h"

#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 112 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
#include <tulip/Graph.h>
#line 26 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

#line 29 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/string.sip"
	// Include the library interface to the type being mapped.
#include <string>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
#include <tulip/PropertyInterface.h>
#line 34 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 29 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Node.sip"
#include <tulip/Node.h>
#line 37 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Iterator.sip"
#include <tulip/Iterator.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 54 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 37 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 57 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 29 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/set.sip"
#include <set>
#line 60 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 113 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 63 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 24 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/ObservableGraph.sip"
#include <tulip/ObservableGraph.h>
#line 80 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 32 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/StringProperty.sip"
#include <tulip/StringProperty.h>
#line 83 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 32 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/ColorProperty.sip"
#include <tulip/ColorProperty.h>
#line 86 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 32 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/SizeProperty.sip"
#include <tulip/SizeProperty.h>
#line 89 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 32 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/BooleanProperty.sip"
#include <tulip/BooleanProperty.h>
#line 92 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 32 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/LayoutProperty.sip"
#include <tulip/LayoutProperty.h>
#line 95 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 32 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DoubleProperty.sip"
#include <tulip/DoubleProperty.h>
#line 98 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 32 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/IntegerProperty.sip"
#include <tulip/IntegerProperty.h>
#line 101 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Iterator.sip"
#include <tulip/Iterator.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 118 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 32 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/GraphProperty.sip"
#include <tulip/GraphProperty.h>
#line 121 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 442 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/IntegerProperty.sip"
#include <tulip/IntegerProperty.h>
#line 124 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 448 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/SizeProperty.sip"
#include <tulip/SizeProperty.h>
#line 127 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 392 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/StringProperty.sip"
#include <tulip/StringProperty.h>
#line 130 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 489 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DoubleProperty.sip"
#include <tulip/DoubleProperty.h>
#line 133 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 392 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/ColorProperty.sip"
#include <tulip/ColorProperty.h>
#line 136 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 1047 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/LayoutProperty.sip"
#include <tulip/LayoutProperty.h>
#line 139 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 442 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/BooleanProperty.sip"
#include <tulip/BooleanProperty.h>
#line 142 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Edge.sip"
#include <tulip/tulipconf.h>
#include <tulip/Edge.h>
#line 146 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 29 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/pair.sip"
#include <utility>
#line 149 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Iterator.sip"
#include <tulip/Iterator.h>
#line 152 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Iterator.sip"
#include <tulip/Iterator.h>
#line 155 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 37 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 158 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 37 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 161 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Observable.sip"
#include <tulip/Observable.h>
#line 178 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 37 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 181 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 54 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Observable.sip"
#include <tulip/Observable.h>
#line 198 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"


PyDoc_STRVAR(doc_tlp_Graph_applyAlgorithm, "tlp.Graph.applyAlgorithm(algoName[, dataSet])\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "	\n"
    "Applies an algorithm plugin, identified by its name.\n"
    "Algorithm plugins are objects implementing the tlp::Algorithm interface \n"
    "in C++ or the :class:`tlp.Algorithm` interface in Python.\n"
    "The list of currently loaded algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getAlgorithmPluginsList` function.\n"
    "Parameters can be transmit to the algorithm using a :class:`tlp.DataSet`.\n"
    "To determine a plugin's parameters, you can either:\n"
    "\n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: The name of the algorithm to apply.\n"
    ":type algoName: string\n"
    ":param dataSet: The parameters to the algorithm. Defaults to :const:`None`.\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_applyAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_applyAlgorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        std::string * a1;
        tlp::DataSet * a2 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_DataSet, &a2))
        {
            bool sipRes = 0;
            a1 = new std::string();
            int sipIsErr = 0;

#line 166 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Algorithm")) {
        sipRes = sipCpp->applyAlgorithm(*a0, *a1, a2);
    } else {
        sipIsErr = 1;
        std::string msg = "No Tulip general algorithm plugin named  ";
        msg += *a0;
        msg += ".";
        PyErr_SetString(PyExc_Exception, msg.c_str());
    }
#line 258 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a1,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_applyAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_clear, "tlp.Graph.clear()\n"
    "\n"
    "Remove all nodes, edges and subgraphs from the graph .");

extern "C" {static PyObject *meth_tlp_Graph_clear(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_clear(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            sipCpp->clear();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_clear, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_addSubGraph, "tlp.Graph.addSubGraph([selection = None])\n"
    "\n"
    "Creates and returns a new sub-graph. The elements of the new sub-graph are those \n"
    "selected in the selection. If there is no selection an empty sub-graph is returned.\n"
    "\n"
    ":param selection: a Boolean property whose selected elements will be added to the sub-graph\n"
    ":type selection: :class:`tlp.BooleanProperty`\n"
    ":rtype: :class:`tlp.Graph`\n"
    "tlp.Graph.addSubGraph(name)\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Creates and returns a new named sub-graph of this graph.\n"
    "\n"
    ":param name: The name of the newly created subgraph.\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_Graph_addSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_addSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::BooleanProperty * a0 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_BooleanProperty, &a0))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->addSubGraph(a0);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    {
        std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->addSubGraph(*a0);
            sipReleaseType(a0,sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_addSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_addCloneSubGraph, "tlp.Graph.addCloneSubGraph(name = \"unnamed\")\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Creates and returns a subgraph of this graph that contains all its elements.\n"
    "\n"
    ":param name: The name of the newly created subgraph. Defaults to \"unnamed\".\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_Graph_addCloneSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_addCloneSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::string a0def = "unnamed";
        std::string * a0 = &a0def;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B|J1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->addCloneSubGraph(*a0);
            sipReleaseType(a0,sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_addCloneSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_inducedSubGraph, "tlp.Graph.inducedSubGraph(nodeSet)\n"
    "\n"
    "Creates and returns a new sub-graph of the graph induced by a set of nodes. \n"
    "The sub-graph contains all the nodes of the set and all the existing edges \n"
    "between two nodes of the set including self-loops.\n"
    "\n"
    ":param nodeSet: the set of nodes from which to build the induced sub-graph\n"
    ":type nodeSet: list of :class:`tlp.node`\n"
    ":rtype: :class:`tlp.Graph` ");

extern "C" {static PyObject *meth_tlp_Graph_inducedSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_inducedSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::set<tlp::node> * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_set_0100tlp_node,&a0, &a0State))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->inducedSubGraph(*a0);
            sipReleaseType(const_cast<std::set<tlp::node> *>(a0),sipType_std_set_0100tlp_node,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_inducedSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_delSubGraph, "tlp.Graph.delSubGraph(subgraph)\n"
    "\n"
    "Delete a sub-graph of this graph. The sub-graph's sub-graphs become sub-graphs of the graph.\n"
    "\n"
    ":param subgraph: the sub-graph to remove\n"
    ":type subgraph: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_Graph_delSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_delSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_Graph, &a0))
        {
#line 258 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
      // the sub-graph will be deleted after the call to tlp::Graph::delSubGraph(tlp::Graph *)
      // we need to release the SIP wrapper associated to the C++ pointer otherwise the following
      // Python code raises a segmentation fault :
      // sg = graph.addSubGraph()
      // graph.delSubGraph(sg)
      // print sg # or any operation on sg
      // An execption is now thrown claiming that the underlying C++ object has been deleted
      releaseGraphWrapper(a0);
      sipCpp->delSubGraph(a0);
#line 468 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_delSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_delAllSubGraphs, "tlp.Graph.delAllSubGraphs(subgraph)\n"
    "\n"
    "Delete a sub-graph of this graph and all its sub-graphs.\n"
    "\n"
    ":param subgraph: the sub-graph to remove\n"
    ":type subgraph: :class:`tlp.Graph` ");

extern "C" {static PyObject *meth_tlp_Graph_delAllSubGraphs(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_delAllSubGraphs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_Graph, &a0))
        {
#line 282 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
      // the sub-graphs will be deleted after the call to tlp::Graph::delAllSubGraphs(tlp::Graph *)
      // we need to release the possible SIP wrappers associated to the C++ pointers otherwise the following
      // Python code raises a segmentation fault :
      // sg = graph.addSubGraph()
      // sg2 = sg.addSubGraph()
      // graph.delAllSubGraphs(sg2)
      // print sg2 # or any operation on sg2
      // An execption is now thrown claiming that the underlying C++ object has been deleted
      releaseGraphHierarchyWrappers(a0);
      sipCpp->delAllSubGraphs(a0);
#line 511 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_delAllSubGraphs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getSuperGraph, "tlp.Graph.getSuperGraph()\n"
    "\n"
    "Returns the parent of the graph, if it has no parent (is the root graph), it returns itself.\n"
    "\n"
    ":rtype: :class:`tlp.Graph` ");

extern "C" {static PyObject *meth_tlp_Graph_getSuperGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getSuperGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->getSuperGraph();

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getSuperGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getRoot, "tlp.Graph.getRoot()\n"
    "\n"
    "Returns the root graph of the graph hierarchy.\n"
    "\n"
    ":rtype: :class:`tlp.Graph` ");

extern "C" {static PyObject *meth_tlp_Graph_getRoot(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getRoot(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->getRoot();

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getRoot, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_setSuperGraph, "tlp.Graph.setSuperGraph(superGraph)\n"
    "\n"
    "Sets the parent of the graph (use very carefully). Standard users should never use this method.\n"
    "\n"
    ":param superGraph: the new parent for the graph in the hierarchy.\n"
    ":type superGraph: :class:`tlp.Graph`\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_setSuperGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_setSuperGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_Graph, &a0))
        {
            sipCpp->setSuperGraph(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_setSuperGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getSubGraphs, "tlp.Graph.getSubGraphs()\n"
    "\n"
    "Returns an iterator on all the sub-graphs of the graph.\n"
    "\n"
    ":rtype: a Tulip iterator on :class:`tlp.Graph` objects");

extern "C" {static PyObject *meth_tlp_Graph_getSubGraphs(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getSubGraphs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::IteratorGraph *sipRes = 0;

#line 341 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = new tlp::StableIterator<tlp::Graph *>(sipCpp->getSubGraphs());
#line 640 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            return sipConvertFromType(sipRes,sipType_tlp_IteratorGraph,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getSubGraphs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_isSubGraph, "tlp.Graph.isSubGraph(graph)\n"
    "\n"
    "Returns :const:`True` if the graph argument is a direct sub-graph of the graph.\n"
    "\n"
    ":param graph: a graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":rtype: boolean ");

extern "C" {static PyObject *meth_tlp_Graph_isSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_isSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_Graph, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->isSubGraph(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_isSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_isDescendantGraph, "tlp.Graph.isDescendantGraph(graph)\n"
    "\n"
    "Returns :const:`True` if the graph argument is a descendant of this graph.\n"
    "\n"
    ":param graph: a graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":rtype: boolean ");

extern "C" {static PyObject *meth_tlp_Graph_isDescendantGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_isDescendantGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_Graph, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->isDescendantGraph(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_isDescendantGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getSubGraph, "tlp.Graph.getSubGraph(id)\n"
    "\n"
    "Returns the sub-graph with the corresponding id or :const:`None` if there is no sub-graph with that id.\n"
    "\n"
    ":param id: a graph id\n"
    ":type id: integer\n"
    ":rtype: :class:`tlp.Graph` or :const:`None` \n"
    "tlp.Graph.getSubGraph(name)\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Returns the sub-graph with the corresponding name or :const:`None` if there is no sub-graph with that name.\n"
    "\n"
    ":param name: the name of the sub-graph to return\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.Graph` or :const:`None` ");

extern "C" {static PyObject *meth_tlp_Graph_getSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bu", &sipSelf, sipType_tlp_Graph, &sipCpp, &a0))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->getSubGraph(a0);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    {
        const std::string * a0;
        int a0State = 0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->getSubGraph(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getDescendantGraph, "tlp.Graph.getDescendantGraph(id)\n"
    "\n"
    "Returns the descendant graph with the corresponding id or :const:`None` if there is no descendant with that id. \n"
    "\n"
    ":param id: a graph id\n"
    ":type id: integer\n"
    ":rtype: :class:`tlp.Graph` or :const:`None` \n"
    "tlp.Graph.getDescendantGraph(name)\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Returns the descendant with the corresponding name or :const:`None` if there is no descendant with that name.\n"
    "\n"
    ":param name: the name of the descendant to return\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.Graph` or :const:`None`");

extern "C" {static PyObject *meth_tlp_Graph_getDescendantGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getDescendantGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bu", &sipSelf, sipType_tlp_Graph, &sipCpp, &a0))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->getDescendantGraph(a0);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    {
        const std::string * a0;
        int a0State = 0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->getDescendantGraph(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getDescendantGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getNthSubGraph, "tlp.Graph.getNthSubGraph(n)\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Returns the nth subgraph or :const:`None` if there is no such sub-graph.\n"
    "Since order cannot be ensured in every implementation, this method should be equivalent to::\n"
    "\n"
    "    i = 0\n"
    "    for sg in graph.getSubGraphs():\n"
    "      if i++ == n:\n"
    "        return sg\n"
    "    return None    \n"
    "       \n"
    ":param n: the index of the sub-graph to return\n"
    ":type n: integer\n"
    ":rtype: :class:`tlp.Graph` or :const:`None`");

extern "C" {static PyObject *meth_tlp_Graph_getNthSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getNthSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bu", &sipSelf, sipType_tlp_Graph, &sipCpp, &a0))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->getNthSubGraph(a0);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getNthSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_numberOfSubGraphs, "tlp.Graph.numberOfSubGraphs()\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "	\n"
    "Returns the number of direct sub-graphs.\n"
    "\n"
    ":rtype: integer");

extern "C" {static PyObject *meth_tlp_Graph_numberOfSubGraphs(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_numberOfSubGraphs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->numberOfSubGraphs();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_numberOfSubGraphs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_numberOfDescendantGraphs, "tlp.Graph.numberOfDescendantGraphs()	\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "	\n"
    "Returns the number of descendant graphs.\n"
    "\n"
    ":rtype: integer	");

extern "C" {static PyObject *meth_tlp_Graph_numberOfDescendantGraphs(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_numberOfDescendantGraphs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->numberOfDescendantGraphs();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_numberOfDescendantGraphs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_addNode, "tlp.Graph.addNode()\n"
    "\n"
    "Adds a new node in the graph and returns it. This node is also added in all \n"
    "the graph's ancestors to maintain the sub-graph relation between graphs.\n"
    "\n"
    ":rtype: :class:`tlp.node`\n"
    "tlp.Graph.addNode(node)\n"
    "\n"
    "Adds an existing node in the graph. This node is also added in all the graph ancestors \n"
    "to maintain the sub-graph relation between graphs.\n"
    "\n"
    ":param node: an existing node to add to the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":throws: an exception if the node does not belong to the root graph\n"
    "\n"
    ".. warning:: The node must be an element of the graph hierarchy, thus it must be an element of the root graph.\n"
    "\n"
    ".. warning:: One can't add an existing node to the root graph.\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_addNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_addNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::node *sipRes;

            sipRes = new tlp::node(sipCpp->addNode());

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    {
        const tlp::node * a0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            int sipIsErr = 0;

#line 526 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->getRoot()->isElement(*a0)) {
		sipCpp->addNode(*a0);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp->getRoot(), *a0);
	}
#line 1000 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_addNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_addNodes, "tlp.Graph.addNodes(nbNodes)\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Adds new nodes in the graph and returns them in a list.\n"
    "The new nodes are also added in all the graph ancestors to maintain the sub-graph relation between graphs.\n"
    "\n"
    ":param nbNodes: the number of nodes to add in the graph\n"
    ":type nbNodes: integer\n"
    ":rtype: list of :class:`tlp.node`\n"
    "\n"
    ".. warning:: the addedNodes vector is cleared before adding nodes.\n"
    "\n"
    "tlp.Graph.addNodes(itNodes)\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Adds existing nodes in the graph. The nodes are also added in all\n"
    "the graph ancestors to maintain the sub-graph relation between graphs.\n"
    "\n"
    ":param itNodes: an iterator on nodes to add\n"
    ":type itNodes: a Tulip iterator on :class:`tlp.node` objects\n"
    ":throws: an exception if one of the node to add is not an element of the root graph.\n"
    "\n"
    ".. warning:: The added nodes must be elements of the graph hierarchy, thus they must be elements of the root graph.\n"
    "\n"
    ".. warning:: One can't add existing nodes to the root graph.\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_addNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_addNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        std::vector<tlp::node> * a1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bu", &sipSelf, sipType_tlp_Graph, &sipCpp, &a0))
        {
            a1 = new std::vector<tlp::node>();

            sipCpp->addNodes(a0,*a1);

            return sipConvertFromNewType(a1,sipType_std_vector_0100tlp_node,NULL);
        }
    }

    {
        tlp::IteratorNode * a0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ:", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_IteratorNode, &a0))
        {
            int sipIsErr = 0;

#line 555 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    tlp::StableIterator<tlp::node> sItNodes(a0);
    tlp::node n;
    while (sItNodes.hasNext()) {
          n = sItNodes.next();
          if (!sipCpp->getRoot()->isElement(n)) {
              sipIsErr = throwInvalidNodeException(sipCpp->getRoot(), n);
              break;
          }
    }

    if (sipIsErr == 0) {
        sItNodes.restart();
        sipCpp->addNodes(&sItNodes);
    }
#line 1089 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_addNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_delNode, "tlp.Graph.delNode(node[, deleteInAllGraphs = False])\n"
    "\n"
    "Deletes a node in the graph. This node is also removed in all the sub-graphs of the graph \n"
    "to maintain the sub-graph relation between graphs. \n"
    "\n"
    ":param node: the node to delete\n"
    ":type node: :class:`tlp.node` \n"
    ":param deleteInAllGraphs: if :const:`True`, remove the node in all the hierarchy of graphs\n"
    ":type deleteInAllGraphs: boolean\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_delNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_delNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        bool a1 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9|b", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0, &a1))
        {
            int sipIsErr = 0;

#line 588 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipCpp->delNode(*a0);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 1137 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_delNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_delNodes, "tlp.Graph.delNodes(itNodes[, deleteInAllGraphs=False])\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Deletes nodes in the graph. These nodes are also removed in\n"
    "the sub-graphs hierarchy of the current graph to maintain\n"
    "the sub-graph relation between graphs.\n"
    "\n"
    ":param itNodes: an iterator on the nodes to add\n"
    ":type itNodes: a Tulip iterator on :class:`tlp.node` objects\n"
    ":param deleteInAllGraphs: if :const:`True`, these nodes are  deleted in the whole hierarchy of graphs.\n"
    ":type deleteInAllGraphs: boolean\n"
    ":throws: an exception if one of the node to delete is not an element of the graph.\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_delNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_delNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::IteratorNode * a0;
        bool a1 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ:|b", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_IteratorNode, &a0, &a1))
        {
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_Graph, sipName_delNodes);
                return NULL;
            }

#line 616 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    tlp::StableIterator<tlp::node> sItNodes(a0);
    tlp::node n;
    while (sItNodes.hasNext()) {
        n = sItNodes.next();
        if (!sipCpp->isElement(n)) {
            sipIsErr = throwInvalidNodeException(sipCpp, n);
            break;
        }
    }

    if (sipIsErr == 0) {
        sItNodes.restart();
        sipCpp->delNodes(&sItNodes, a1);
    }
#line 1205 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_delNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_addEdge, "tlp.Graph.addEdge(src, tgt)\n"
    "\n"
    "Adds a new edge in the graph and returns it. This edge is also added in all \n"
    "the graph's ancestors to maintain the sub-graph relation between graphs.\n"
    "\n"
    ":param src: the source node of the new edge\n"
    ":param tgt: the target node of the new edge\n"
    ":type src: :class:`tlp.node`\n"
    ":type tgt: :class:`tlp.node`\n"
    ":rtype: :class:`tlp.edge`\n"
    ":throws: an exception if the provided source or target node does not belong to the graph\n"
    "tlp.Graph.addEdge(edge)\n"
    "\n"
    "Adds an existing edge in the graph. This edge is also added in all \n"
    "the graph's ancestors to maintain the sub-graph relation between graphs. \n"
    "\n"
    ":param edge: an existing edge to add to the graph\n"
    ":type edge: :class:`tlp.edge`\n"
    ":throws: an exception if the edge does not belong to the root graph of if the source and target node of the edge are not elements of the graph\n"
    "\n"
    ".. warning:: The edge must be an element of the graph hierarchy, thus it must be an element of the root graph.\n"
    "\n"
    ".. warning:: One can't add an existing edge to the root graph.\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_addEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_addEdge(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::node * a1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0, sipType_tlp_node, &a1))
        {
            tlp::edge *sipRes = 0;
            int sipIsErr = 0;

#line 650 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (sipCpp->isElement(*a1)) {
			sipRes = new tlp::edge(sipCpp->addEdge(*a0, *a1));
		} else {
			sipIsErr = throwInvalidNodeException(sipCpp, *a1);
		}
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 1272 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_edge,NULL);
        }
    }

    {
        const tlp::edge * a0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0))
        {
            int sipIsErr = 0;

#line 713 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->getRoot()->isElement(*a0)) {
            if (sipCpp->isElement(sipCpp->getRoot()->source(*a0))) {
                if (sipCpp->isElement(sipCpp->getRoot()->target(*a0))) {
                    sipCpp->addEdge(*a0);
                } else {
                    std::ostringstream oss;
                    oss << "Error : edge " << a0->id << " can not be added in graph \\\"" << sipCpp->getName() << "\\\" (id " << sipCpp->getId() << ") "
                        << "because the graph does not contain its target node.";
                    printErrorMessage(oss.str());
                    sipIsErr = throwInvalidNodeException(sipCpp, sipCpp->getRoot()->target(*a0));
                }
            } else {
                std::ostringstream oss;
                oss << "Error : edge " << a0->id << " can not be added in graph \\\"" << sipCpp->getName() << "\\\" (id " << sipCpp->getId() << ") "
                    << "because the graph does not contain its source node.";
                printErrorMessage(oss.str());
                sipIsErr = throwInvalidNodeException(sipCpp, sipCpp->getRoot()->source(*a0));
            }
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp->getRoot(), *a0);
	}
#line 1311 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_addEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_addEdges, "tlp.Graph.addEdges(edges)\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Adds new edges in the graph and returns them in a list.\n"
    "The new edges are also added in all the graph ancestors to maintain the sub-graph relation between graphs.\n"
    "\n"
    ":param edges: the list of edges to add described by a pair of nodes\n"
    ":type edges: list of tuples containing two :class:`tlp.node` objects\n"
    ":rtype: list of :class:`tlp.edge`\n"
    ":throws: an exception if of the provided nodes to link is not an element of the graph.\n"
    "tlp.Graph.addEdges(itEdges)\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Adds existing edges in the graph. The edges are also added in all\n"
    "the graph ancestors to maintain the sub-graph relation between graphs.\n"
    "\n"
    ":param itEdges: an iterator on the edges to add\n"
    ":type itEdges: a Tulip iterator on :class:`tlp.edge` objects\n"
    ":throws: an exception if one of the edge to add is not an element of the root graph or if one of the edges extremities is not an element of the graph.\n"
    "\n"
    ".. warning:: The added edges must be elements of the graph hierarchy, thus they must be elements of the root graph.\n"
    "\n"
    ".. warning : One can't add existing edges to the root graph.");

extern "C" {static PyObject *meth_tlp_Graph_addEdges(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_addEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<std_pair_0100tlp_node_0100tlp_node> * a0;
        int a0State = 0;
        std::vector<tlp::edge> * a1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_vector_0100std_pair_0100tlp_node_0100tlp_node,&a0, &a0State))
        {
            a1 = new std::vector<tlp::edge>();
            int sipIsErr = 0;

#line 679 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
      for (size_t i = 0 ; i < a0->size() ; ++i) {
        if (!sipCpp->isElement((*a0)[i].first)) {
            sipIsErr = throwInvalidNodeException(sipCpp, (*a0)[i].first);
        }
        if (!sipCpp->isElement((*a0)[i].second)) {
            sipIsErr = throwInvalidNodeException(sipCpp, (*a0)[i].second);
        }
      }
      if (sipIsErr == 0) {
        sipCpp->addEdges(*a0, *a1);
      }
#line 1382 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::vector<std_pair_0100tlp_node_0100tlp_node> *>(a0),sipType_std_vector_0100std_pair_0100tlp_node_0100tlp_node,a0State);

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(a1,sipType_std_vector_0100tlp_edge,NULL);
        }
    }

    {
        tlp::IteratorEdge * a0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ:", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_IteratorEdge, &a0))
        {
            int sipIsErr = 0;

#line 757 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    tlp::StableIterator<tlp::edge> sItEdges(a0);
    tlp::edge e;
    while (sItEdges.hasNext()) {
        e = sItEdges.next();
        if (!sipCpp->getRoot()->isElement(e)) {
                sipIsErr = throwInvalidEdgeException(sipCpp->getRoot(), e);
                break;
        } else {
            if (!sipCpp->isElement(sipCpp->getRoot()->source(e))) {
                std::ostringstream oss;
                oss << "Error : edge " << e.id << " can not be added in graph \\\"" << sipCpp->getName() << "\\\" (id " << sipCpp->getId() << ") "
                    << "because the graph does not contain its source node.";
                printErrorMessage(oss.str());
                sipIsErr = throwInvalidNodeException(sipCpp, sipCpp->getRoot()->source(e));
                break;
            }
            if (!sipCpp->isElement(sipCpp->getRoot()->target(e))) {
                std::ostringstream oss;
                oss << "Error : edge " << e.id << " can not be added in graph \\\"" << sipCpp->getName() << "\\\" (id " << sipCpp->getId() << ") "
                    << "because the graph does not contain its target node.";
                printErrorMessage(oss.str());
                sipIsErr = throwInvalidNodeException(sipCpp, sipCpp->getRoot()->target(e));
                break;
            }
        }
    }

    if (sipIsErr == 0) {
        sItEdges.restart();
        sipCpp->delEdges(&sItEdges);
    }
#line 1432 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_addEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_delEdge, "tlp.Graph.delEdge(edge[, deleteInAllGraphs = False])\n"
    "\n"
    "Deletes an edge in the graph. This edge is also removed in all the sub-graphs \n"
    "of the graph to maintain the sub-graph relation between graphs. The ordering of edges is preserved. \n"
    "\n"
    ":param edge: the edge to delete\n"
    ":type edge: :class:`tlp.edge` \n"
    ":param deleteInAllGraphs: if :const:`True`, remove the edge in all the hierarchy of graphs\n"
    ":type deleteInAllGraphs: boolean\n"
    ":throws: an exception if the edge does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_delEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_delEdge(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        bool a1 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9|b", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0, &a1))
        {
            int sipIsErr = 0;

#line 806 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipCpp->delEdge(*a0);
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 1480 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_delEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_delEdges, "tlp.Graph.delEdges(itEdges[, deleteInAllGraphs=False])\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Deletes edges in the graph. These edges are also removed in\n"
    "the sub-graphs hierarchy of the current graph to maintain\n"
    "the sub-graph relation between graphs.\n"
    "The ordering of remaining edges is preserved.\n"
    "\n"
    ":param itEdges: an iterator on the edges to delete\n"
    ":type itEdges: a Tulip iterator on :class:`tlp.edge` objects\n"
    ":param deleteInAllGraphs: If :const:`True`, the edges are deleted in the whole hierarchy of graphs.\n"
    ":param deleteInAllGraphs: boolean\n"
    ":throws: an exception if one of the edge to delete is not an element of the graph");

extern "C" {static PyObject *meth_tlp_Graph_delEdges(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_delEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::IteratorEdge * a0;
        bool a1 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ:|b", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_IteratorEdge, &a0, &a1))
        {
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_Graph, sipName_delEdges);
                return NULL;
            }

#line 834 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    tlp::StableIterator<tlp::edge> sItEdges(a0);
    tlp::edge e;
    while (sItEdges.hasNext()) {
        e = sItEdges.next();
        if (!sipCpp->isElement(e)) {
            sipIsErr = throwInvalidEdgeException(sipCpp, e);
            break;
        }
    }
    if (sipIsErr == 0) {
        sItEdges.restart();
        sipCpp->delEdges(&sItEdges, a1);
    }
#line 1547 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_delEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_setEdgeOrder, "tlp.Graph.setEdgeOrder(node, edges)\n"
    "\n"
    "Sets the order of the edges around a node. This operation ensures that adjacent edges \n"
    "of a node will be ordered as they are in the list of edges given in parameter.\n"
    "\n"
    ":param node: the node on which to set edges ordering\n"
    ":type node: :class:`tlp.node`\n"
    ":param edges: the list of edges adjacent to the node\n"
    ":type edges: list of :class:`tlp.edge`\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_setEdgeOrder(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_setEdgeOrder(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const std::vector<tlp::edge> * a1;
        int a1State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0, sipType_std_vector_0100tlp_edge,&a1, &a1State))
        {
            int sipIsErr = 0;

#line 866 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipCpp->setEdgeOrder(*a0, *a1);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 1596 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::vector<tlp::edge> *>(a1),sipType_std_vector_0100tlp_edge,a1State);

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_setEdgeOrder, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_swapEdgeOrder, "tlp.Graph.swapEdgeOrder(node, edge1, edge2)\n"
    "\n"
    "Swaps two edges in the adjacency list of a node.\n"
    "\n"
    ":param node: the node on which swapping two edges in its adjacency list\n"
    ":type node: :class:`tlp.node`\n"
    ":param edge1: an edge adjacent to the node\n"
    ":param edge2: another edge adjacent to the node\n"
    ":type edge1: :class:`tlp.edge`\n"
    ":type edge2: :class:`tlp.edge`\n"
    ":throws: an exception if the node or one of the edges does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_swapEdgeOrder(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_swapEdgeOrder(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::edge * a1;
        const tlp::edge * a2;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9J9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0, sipType_tlp_edge, &a1, sipType_tlp_edge, &a2))
        {
            int sipIsErr = 0;

#line 891 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (sipCpp->isElement(*a1)) {
			if (sipCpp->isElement(*a2)) {
				sipCpp->swapEdgeOrder(*a0, *a1, *a2);
			} else {
				sipIsErr = throwInvalidEdgeException(sipCpp, *a2);
			}
		} else {
			sipIsErr = throwInvalidEdgeException(sipCpp, *a1);
		}
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 1655 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_swapEdgeOrder, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_setSource, "tlp.Graph.setSource(edge, src)\n"
    "\n"
    "Sets the source of an existing edge.\n"
    "\n"
    ":param edge: the edge on which to change the source node\n"
    ":type edge: :class:`tlp.edge`\n"
    ":param src: the new source node of the edge\n"
    ":type src: :class:`tlp.node`\n"
    ":throws: an exception if the edge or the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_setSource(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_setSource(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::node * a1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0, sipType_tlp_node, &a1))
        {
            int sipIsErr = 0;

#line 922 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (sipCpp->isElement(*a1)) {
			sipCpp->setSource(*a0, *a1);
		} else {
			sipIsErr = throwInvalidNodeException(sipCpp, *a1);
		}
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 1706 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_setSource, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_setTarget, "tlp.Graph.setTarget(edge, tgt)\n"
    "\n"
    "Sets the target of an existing edge.\n"
    "\n"
    ":param edge: the edge on which to change the target node\n"
    ":type edge: :class:`tlp.edge`\n"
    ":param tgt: the new target node of the edge\n"
    ":type tgt: :class:`tlp.node`\n"
    ":throws: an exception if the edge or node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_setTarget(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_setTarget(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::node * a1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0, sipType_tlp_node, &a1))
        {
            int sipIsErr = 0;

#line 949 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (sipCpp->isElement(*a1)) {
			sipCpp->setTarget(*a0, *a1);
		} else {
			sipIsErr = throwInvalidNodeException(sipCpp, *a1);
		}
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 1757 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_setTarget, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_setEnds, "tlp.Graph.setEnds(edge, src, tgt)\n"
    "\n"
    "Sets both the source and target of an existing edge. \n"
    "\n"
    ":param edge: the edge on which to change the source and target nodes\n"
    ":type edge: :class:`tlp.edge`\n"
    ":param src: the new source node of the edge\n"
    ":type src: :class:`tlp.node`\n"
    ":param tgt: the new target node of the edge\n"
    ":type tgt: :class:`tlp.node`\n"
    ":throws: an exception if the edge or one of the nodes does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_setEnds(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_setEnds(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::node * a1;
        const tlp::node * a2;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9J9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0, sipType_tlp_node, &a1, sipType_tlp_node, &a2))
        {
            int sipIsErr = 0;

#line 979 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (sipCpp->isElement(*a1)) {
			if (sipCpp->isElement(*a2)) {
				sipCpp->setEnds(*a0, *a1, *a2);
			} else {
				sipIsErr = throwInvalidNodeException(sipCpp, *a2);
			}
		} else {
			sipIsErr = throwInvalidNodeException(sipCpp, *a1);
		}
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 1815 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_setEnds, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_reverse, "tlp.Graph.reverse(edge)\n"
    "\n"
    "Reverses the direction of an edge, the source becomes the target \n"
    "and the target becomes the source. \n"
    "\n"
    ":param edge: the edge on which to revert the direction.\n"
    ":type edge: :class:`tlp.edge` \n"
    ":throws: an exception if the edge does not belong to the graph\n"
    "\n"
    ".. warning:: The ordering is global to the entire graph hierarchy. Thus, by changing the ordering in a graph you change the ordering in the hierarchy.\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_reverse(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_reverse(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0))
        {
            int sipIsErr = 0;

#line 1012 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipCpp->reverse(*a0);
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 1863 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_reverse, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getOneNode, "tlp.Graph.getOneNode()\n"
    "\n"
    "Returns an existing node of the graph.\n"
    "\n"
    ":rtype: :class:`tlp.node`  ");

extern "C" {static PyObject *meth_tlp_Graph_getOneNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getOneNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::node *sipRes;

            sipRes = new tlp::node(sipCpp->getOneNode());

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getOneNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getSource, "tlp.Graph.getSource()\n"
    "\n"
    ".. versionadded:: 3.7\n"
    "\n"
    "Finds the first node whose input degree equals 0.\n"
    "Returns the found node (invalid if there is no source);\n"
    "\n"
    ":rtype: :class:`tlp.node`");

extern "C" {static PyObject *meth_tlp_Graph_getSource(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getSource(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::node *sipRes;

            sipRes = new tlp::node(sipCpp->getSource());

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getSource, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getNodes, "tlp.Graph.getNodes()\n"
    "\n"
    "Returns an iterator on the nodes.\n"
    "\n"
    ":rtype: a Tulip iterator on :class:`tlp.node` objects");

extern "C" {static PyObject *meth_tlp_Graph_getNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::IteratorNode *sipRes = 0;

#line 1056 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = new tlp::StableIterator<tlp::node>(sipCpp->getNodes());
#line 1965 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            return sipConvertFromType(sipRes,sipType_tlp_IteratorNode,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getInNode, "tlp.Graph.getInNode(node, i)\n"
    "\n"
    "Returns the ith predecessor of a node. \n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":param i: the position in the predecessor nodes list (warning : first index is 1 not 0)\n"
    ":type i: integer\n"
    ":throws: an exception if the node does not belong to the graph or if the requested index is lesser than the number of predecessor nodes");

extern "C" {static PyObject *meth_tlp_Graph_getInNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getInNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        uint a1;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9u", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0, &a1))
        {
            tlp::node *sipRes = 0;
            int sipIsErr = 0;

#line 1076 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (a1 == 0) {
			PyErr_SetString(PyExc_Exception, "Error : first index for tlp.Graph.getInNode is 1 not 0");
			sipIsErr = -1;
		} else if (a1 <= sipCpp->indeg(*a0)) {
			sipRes = new tlp::node(sipCpp->getInNode(*a0, a1));
		} else {
			std::ostringstream oss;
			std::string graphName;
			sipCpp->getAttribute("name", graphName);
			oss << "node with id " << a0->id << " belonging to graph \"" << graphName << "\" (id " << sipCpp->getId() << ") has " << sipCpp->indeg(*a0) << " predecessor nodes and the requested index is " << a1; 
			PyErr_SetString(PyExc_Exception, oss.str().c_str());
			sipIsErr = -1;
		}
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2021 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getInNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getInNodes, "tlp.Graph.getInNodes(node)\n"
    "\n"
    "Return an iterator on the predecessors of a node. \n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: a Tulip iterator on :class:`tlp.node` objects\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_getInNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getInNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            tlp::IteratorNode *sipRes = 0;
            int sipIsErr = 0;

#line 1110 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::StableIterator<tlp::node>(sipCpp->getInNodes(*a0));
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2066 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_IteratorNode,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getInNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getOutNode, "tlp.Graph.getOutNode(node, i)\n"
    "\n"
    "Returns the ith successor of a node. \n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":param i: the position in the successor nodes list (warning : first index is 1 not 0)\n"
    ":type i: integer\n"
    ":throws: an exception if the node does not belong to the graph or if the requested index is lesser than the number of successor nodes");

extern "C" {static PyObject *meth_tlp_Graph_getOutNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getOutNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        uint a1;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9u", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0, &a1))
        {
            tlp::node *sipRes = 0;
            int sipIsErr = 0;

#line 1133 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (a1 == 0) {
			PyErr_SetString(PyExc_Exception, "Error : first index for tlp.Graph.getOutNode is 1 not 0");
			sipIsErr = -1;
		}else if (a1 <= sipCpp->outdeg(*a0)) {
			sipRes = new tlp::node(sipCpp->getOutNode(*a0, a1));
		} else {
			std::ostringstream oss;
			std::string graphName;
			sipCpp->getAttribute("name", graphName);
			oss << "node with id " << a0->id << " belonging to graph \"" << graphName << "\" (id " << sipCpp->getId() << ") has " << sipCpp->outdeg(*a0) << " successor nodes and the requested index is " << a1; 
			PyErr_SetString(PyExc_Exception, oss.str().c_str());
			sipIsErr = -1;
		}
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
	
#line 2126 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getOutNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getOutNodes, "tlp.Graph.getOutNodes(node)\n"
    "\n"
    "Returns an iterator on the successors of a node. \n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: a Tulip iterator on :class:`tlp.node` objects\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_getOutNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getOutNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            tlp::IteratorNode *sipRes = 0;
            int sipIsErr = 0;

#line 1168 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::StableIterator<tlp::node>(sipCpp->getOutNodes(*a0));
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2171 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_IteratorNode,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getOutNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getInOutNodes, "tlp.Graph.getInOutNodes(node)\n"
    "\n"
    "Returns an iterator on the neighbours of a node. \n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: a Tulip iterator on :class:`tlp.node` objects\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_getInOutNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getInOutNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            tlp::IteratorNode *sipRes = 0;
            int sipIsErr = 0;

#line 1190 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::StableIterator<tlp::node>(sipCpp->getInOutNodes(*a0));
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}	
#line 2216 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_IteratorNode,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getInOutNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getNodeMetaInfo, "tlp.Graph.getNodeMetaInfo(node)\n"
    "\n"
    "Returns the underlying graph of a meta node.\n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: :class:`tlp.Graph`\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_getNodeMetaInfo(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getNodeMetaInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            tlp::Graph *sipRes = 0;
            int sipIsErr = 0;

#line 1212 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = sipCpp->getNodeMetaInfo(*a0);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}	
#line 2261 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getNodeMetaInfo, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getEdges, "tlp.Graph.getEdges()\n"
    "\n"
    "Returns an iterator on the edges.\n"
    "\n"
    ":rtype: a Tulip iterator on :class:`tlp.edge` objects");

extern "C" {static PyObject *meth_tlp_Graph_getEdges(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::IteratorEdge *sipRes = 0;

#line 1231 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = new tlp::StableIterator<tlp::edge>(sipCpp->getEdges());
#line 2297 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            return sipConvertFromType(sipRes,sipType_tlp_IteratorEdge,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getOneEdge, "tlp.Graph.getOneEdge()\n"
    "\n"
    "Returns an existing edge of the graph.\n"
    "\n"
    ":rtype: :class:`tlp.edge`  ");

extern "C" {static PyObject *meth_tlp_Graph_getOneEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getOneEdge(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::edge *sipRes;

            sipRes = new tlp::edge(sipCpp->getOneEdge());

            return sipConvertFromNewType(sipRes,sipType_tlp_edge,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getOneEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getOutEdges, "tlp.Graph.getOutEdges(node)\n"
    "\n"
    "Returns a Tulip iterator on the outgoing edges of a node.\n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: a Tulip iterator on :class:`tlp.edge` objects\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_getOutEdges(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getOutEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            tlp::IteratorEdge *sipRes = 0;
            int sipIsErr = 0;

#line 1260 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::StableIterator<tlp::edge>(sipCpp->getOutEdges(*a0));
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2370 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_IteratorEdge,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getOutEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getInOutEdges, "tlp.Graph.getInOutEdges(node)\n"
    "\n"
    "Returns an iterator on the incoming and outgoing edges of a node.\n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: a Tulip iterator on :class:`tlp.edge` objects\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_getInOutEdges(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getInOutEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            tlp::IteratorEdge *sipRes = 0;
            int sipIsErr = 0;

#line 1282 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::StableIterator<tlp::edge>(sipCpp->getInOutEdges(*a0));
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2415 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_IteratorEdge,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getInOutEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getInEdges, "tlp.Graph.getInEdges(node)\n"
    "\n"
    "Returns an iterator on the incoming edges of a node.\n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: a Tulip iterator on :class:`tlp.edge` objects\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_getInEdges(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getInEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            tlp::IteratorEdge *sipRes = 0;
            int sipIsErr = 0;

#line 1304 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::StableIterator<tlp::edge>(sipCpp->getInEdges(*a0));
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2460 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_IteratorEdge,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getInEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getEdgeMetaInfo, "tlp.Graph.getEdgeMetaInfo(edge)\n"
    "\n"
    "Returns an iterator on the underlying edges of a meta edge.\n"
    "\n"
    ":param edge: an existing edge of the graph\n"
    ":type edge: :class:`tlp.edge`\n"
    ":rtype: a Tulip iterator on :class:`tlp.edge` objects\n"
    ":throws: an exception if the edge does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_getEdgeMetaInfo(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getEdgeMetaInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0))
        {
            tlp::IteratorEdge *sipRes = 0;
            int sipIsErr = 0;

#line 1326 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::StableIterator<tlp::edge>(sipCpp->getEdgeMetaInfo(*a0));
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 2505 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_IteratorEdge,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getEdgeMetaInfo, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getId, "tlp.Graph.getId()\n"
    "\n"
    "Returns the graph's id. This id is unique.\n"
    "\n"
    ":rtype: integer");

extern "C" {static PyObject *meth_tlp_Graph_getId(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getId(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getId();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getId, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_numberOfNodes, "tlp.Graph.numberOfNodes()\n"
    "\n"
    "Returns the number of nodes in the graph.\n"
    "\n"
    ":rtype: integer");

extern "C" {static PyObject *meth_tlp_Graph_numberOfNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_numberOfNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->numberOfNodes();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_numberOfNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_numberOfEdges, "tlp.Graph.numberOfEdges()\n"
    "\n"
    "Returns the number of edges in the graph.\n"
    "\n"
    ":rtype: integer");

extern "C" {static PyObject *meth_tlp_Graph_numberOfEdges(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_numberOfEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->numberOfEdges();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_numberOfEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_deg, "tlp.Graph.deg(node)\n"
    "\n"
    "Returns the degree of a node.\n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: integer\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_deg(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_deg(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            uint sipRes = 0;
            int sipIsErr = 0;

#line 1382 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = sipCpp->deg(*a0);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2643 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_deg, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_indeg, "tlp.Graph.indeg(node)\n"
    "\n"
    "Returns the incoming degree of a node.\n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: integer\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_indeg(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_indeg(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            uint sipRes = 0;
            int sipIsErr = 0;

#line 1404 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = sipCpp->indeg(*a0);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2688 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_indeg, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_outdeg, "tlp.Graph.outdeg(node)\n"
    "\n"
    "Returns the outgoing degree of a node.\n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: integer\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_outdeg(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_outdeg(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            uint sipRes = 0;
            int sipIsErr = 0;

#line 1426 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = sipCpp->outdeg(*a0);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 2733 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_outdeg, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_source, "tlp.Graph.source(edge)\n"
    "\n"
    "Returns the source of the edge.\n"
    "\n"
    ":param edge: an existing edge of the graph\n"
    ":type edge: :class:`tlp.edge`\n"
    ":rtype: :class:`tlp.node`\n"
    ":throws: an exception if the edge does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_source(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_source(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0))
        {
            tlp::node *sipRes = 0;
            int sipIsErr = 0;

#line 1448 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::node(sipCpp->source(*a0));
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 2778 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_source, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_target, "tlp.Graph.target(edge)\n"
    "\n"
    "Returns the target of the edge.\n"
    "\n"
    ":param edge: an existing edge of the graph\n"
    ":type edge: :class:`tlp.edge`\n"
    ":rtype: :class:`tlp.node`\n"
    ":throws: an exception if the edge does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_target(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_target(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0))
        {
            tlp::node *sipRes = 0;
            int sipIsErr = 0;

#line 1470 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new tlp::node(sipCpp->target(*a0));
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 2823 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_target, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_ends, "tlp.Graph.ends(edge)\n"
    "\n"
    "Returns a tuple containing the two end nodes of an edge\n"
    "\n"
    ":param edge: an existing edge of the graph\n"
    ":type node: :class:`tlp.edge`\n"
    ":rtype: (:class:`tlp.node`, :class:`tlp.node`) \n"
    ":throws: an exception if the edge does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_ends(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_ends(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0))
        {
            std::pair<tlp::node,tlp::node> *sipRes = 0;
            int sipIsErr = 0;

#line 1493 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = new std::pair<tlp::node, tlp::node>(sipCpp->ends(*a0));
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 2868 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_pair_0100tlp_node_0100tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_ends, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_opposite, "tlp.Graph.opposite(edge, node)\n"
    "\n"
    "Returns the opposite node of the edge for the given node.\n"
    "\n"
    ":param edge: an existing edge of the graph\n"
    ":type edge: :class:`tlp.edge`\n"
    ":rtype: :class:`tlp.node`\n"
    ":throws: an exception if the edge does not belong to the graph or if the given node is not linked by the edge");

extern "C" {static PyObject *meth_tlp_Graph_opposite(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_opposite(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::node * a1;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0, sipType_tlp_node, &a1))
        {
            tlp::node *sipRes = 0;
            int sipIsErr = 0;

#line 1515 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (sipCpp->source(*a0) == *a1 || sipCpp->target(*a0) == *a1) {  
			sipRes = new tlp::node(sipCpp->opposite(*a0, *a1));
		} else {
			std::ostringstream oss;
			oss << "node with id " << a1->id << " is not linked by the edge with id " << a0->id,
			PyErr_SetString(PyExc_Exception, oss.str().c_str());
			sipIsErr = -1;
		}
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 2921 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_opposite, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_isElement, "tlp.Graph.isElement(node)\n"
    "\n"
    "Returns :const:`True` if the node is an element of the graph.\n"
    "\n"
    ":param node: a node\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: boolean\n"
    "tlp.Graph.isElement(edge)\n"
    "\n"
    "Returns :const:`True` if the edge is an element of the graph.\n"
    "\n"
    ":param edge: an edge\n"
    ":type edge: :class:`tlp.edge`\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_Graph_isElement(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_isElement(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->isElement(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const tlp::edge * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->isElement(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_isElement, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_isMetaNode, "tlp.Graph.isMetaNode(node)\n"
    "\n"
    "Returns :const:`True` if the node is a meta-node.\n"
    "\n"
    ":param node: an existing node of the graph\n"
    ":type node: :class:`tlp.edge`\n"
    ":rtype: boolean\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_isMetaNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_isMetaNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0))
        {
            bool sipRes = 0;
            int sipIsErr = 0;

#line 1570 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = sipCpp->isMetaNode(*a0);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 3021 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_isMetaNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_isMetaEdge, "tlp.Graph.isMetaEdge(edge)\n"
    "\n"
    "Returns :const:`True` if the edge is a meta-edge.\n"
    "\n"
    ":param edge: an existing edge of the graph\n"
    ":type node: :class:`tlp.edge`\n"
    ":rtype: boolean\n"
    ":throws: an exception if the edge does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_isMetaEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_isMetaEdge(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::edge * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_edge, &a0))
        {
            bool sipRes = 0;
            int sipIsErr = 0;

#line 1592 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		sipRes = sipCpp->isMetaEdge(*a0);
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp, *a0);
	}
#line 3066 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_isMetaEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_existEdge, "tlp.Graph.existEdge(node1, node2[, directed=True])\n"
    "\n"
    "Returns the edge if it exists an edge between two nodes.\n"
    "If no edge is found, returns an invalid edge.\n"
    "\n"
    ":param node1: an existing node of the graph\n"
    ":type node1: :class:`tlp.node`\n"
    ":param node2: an existing node of the graph\n"
    ":type node2: :class:`tlp.node`\n"
    ":param directed: indicates if the direction of the edge (from source to target) must be taken in to account\n"
    ":type directed: boolean\n"
    ":rtype: boolean\n"
    ":throws: an exception if one of the nodes does not belong to the graph");

extern "C" {static PyObject *meth_tlp_Graph_existEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_existEdge(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const tlp::node * a1;
        bool a2 = 1;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9|b", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0, sipType_tlp_node, &a1, &a2))
        {
            tlp::edge *sipRes = 0;
            int sipIsErr = 0;

#line 1619 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	if (sipCpp->isElement(*a0)) {
		if (sipCpp->isElement(*a1)) {
			sipRes = new tlp::edge(sipCpp->existEdge(*a0, *a1, a2));
		} else {
			sipIsErr = throwInvalidNodeException(sipCpp, *a1);
		}
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp, *a0);
	}
#line 3122 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_edge,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_existEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getBooleanProperty, "tlp.Graph.getBooleanProperty(name)\n"
    "\n"
    "Returns the boolean property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the boolean property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.BooleanProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getBooleanProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getBooleanProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::BooleanProperty *sipRes = 0;

#line 1646 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::BooleanProperty>(*a0);
#line 3164 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_BooleanProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getBooleanProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalBooleanProperty, "tlp.Graph.getLocalBooleanProperty(name)\n"
    "\n"
    "Returns the boolean property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the boolean property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.BooleanProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalBooleanProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalBooleanProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::BooleanProperty *sipRes = 0;

#line 1665 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::BooleanProperty>(*a0);
#line 3204 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_BooleanProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalBooleanProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getBooleanVectorProperty, "tlp.Graph.getBooleanVectorProperty(name)\n"
    "\n"
    "Returns the boolean vector property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the boolean vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.BooleanVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getBooleanVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getBooleanVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::BooleanVectorProperty *sipRes = 0;

#line 1684 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::BooleanVectorProperty>(*a0);
#line 3244 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_BooleanVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getBooleanVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalBooleanVectorProperty, "tlp.Graph.getLocalBooleanVectorProperty(name)\n"
    "\n"
    "Returns the boolean vector property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the boolean vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.BooleanVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalBooleanVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalBooleanVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::BooleanVectorProperty *sipRes = 0;

#line 1703 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::BooleanVectorProperty>(*a0);
#line 3284 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_BooleanVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalBooleanVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLayoutProperty, "tlp.Graph.getLayoutProperty(name)\n"
    "\n"
    "Returns the layout property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the layout property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.LayoutProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLayoutProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLayoutProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::LayoutProperty *sipRes = 0;

#line 1722 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::LayoutProperty>(*a0);
#line 3324 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_LayoutProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLayoutProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalLayoutProperty, "tlp.Graph.getLocalLayoutProperty(name)\n"
    "\n"
    "Returns the layout property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the layout property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.LayoutProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalLayoutProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalLayoutProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::LayoutProperty *sipRes = 0;

#line 1741 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::LayoutProperty>(*a0);
#line 3364 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_LayoutProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalLayoutProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getCoordVectorProperty, "tlp.Graph.getCoordVectorProperty(name)\n"
    "\n"
    "Returns the coord vector property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the coord vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.CoordVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getCoordVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getCoordVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::CoordVectorProperty *sipRes = 0;

#line 1760 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::CoordVectorProperty>(*a0);
#line 3404 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_CoordVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getCoordVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalCoordVectorProperty, "tlp.Graph.getLocalCoordVectorProperty(name)\n"
    "\n"
    "Returns the coord vector property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the coord vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.CoordVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalCoordVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalCoordVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::CoordVectorProperty *sipRes = 0;

#line 1779 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::CoordVectorProperty>(*a0);
#line 3444 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_CoordVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalCoordVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getColorProperty, "tlp.Graph.getColorProperty(name)\n"
    "\n"
    "Returns the color property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the color property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.ColorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getColorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getColorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::ColorProperty *sipRes = 0;

#line 1798 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::ColorProperty>(*a0);
#line 3484 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_ColorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getColorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalColorProperty, "tlp.Graph.getLocalColorProperty(name)\n"
    "\n"
    "Returns the color property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the color property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.ColorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalColorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalColorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::ColorProperty *sipRes = 0;

#line 1817 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::ColorProperty>(*a0);
#line 3524 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_ColorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalColorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getColorVectorProperty, "tlp.Graph.getColorVectorProperty(name)\n"
    "\n"
    "Returns the color vector property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the color vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.ColorVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getColorVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getColorVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::ColorVectorProperty *sipRes = 0;

#line 1836 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::ColorVectorProperty>(*a0);
#line 3564 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_ColorVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getColorVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalColorVectorProperty, "tlp.Graph.getLocalColorVectorProperty(name)\n"
    "\n"
    "Returns the color vector property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the color vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.ColorVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalColorVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalColorVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::ColorVectorProperty *sipRes = 0;

#line 1855 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::ColorVectorProperty>(*a0);
#line 3604 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_ColorVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalColorVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getDoubleProperty, "tlp.Graph.getDoubleProperty(name)\n"
    "\n"
    "Returns the double property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the double property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.DoubleProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getDoubleProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getDoubleProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::DoubleProperty *sipRes = 0;

#line 1874 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::DoubleProperty>(*a0);
#line 3644 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_DoubleProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getDoubleProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalDoubleProperty, "tlp.Graph.getLocalDoubleProperty(name)\n"
    "\n"
    "Returns the double property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the double property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.DoubleProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalDoubleProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalDoubleProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::DoubleProperty *sipRes = 0;

#line 1893 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::DoubleProperty>(*a0);
#line 3684 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_DoubleProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalDoubleProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getDoubleVectorProperty, "tlp.Graph.getDoubleVectorProperty(name)\n"
    "\n"
    "Returns the double vector property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the double vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.DoubleVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getDoubleVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getDoubleVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::DoubleVectorProperty *sipRes = 0;

#line 1912 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::DoubleVectorProperty>(*a0);
#line 3724 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_DoubleVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getDoubleVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalDoubleVectorProperty, "tlp.Graph.getLocalDoubleVectorProperty(name)\n"
    "\n"
    "Returns the double vector property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the double vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.DoubleVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalDoubleVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalDoubleVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::DoubleVectorProperty *sipRes = 0;

#line 1931 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::DoubleVectorProperty>(*a0);
#line 3764 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_DoubleVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalDoubleVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getStringProperty, "tlp.Graph.getStringProperty(name)\n"
    "\n"
    "Returns the string property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the string property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.StringProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getStringProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getStringProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::StringProperty *sipRes = 0;

#line 1950 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::StringProperty>(*a0);
#line 3804 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_StringProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getStringProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalStringProperty, "tlp.Graph.getLocalStringProperty(name)\n"
    "\n"
    "Returns the string property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the string property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.StringProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalStringProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalStringProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::StringProperty *sipRes = 0;

#line 1969 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::StringProperty>(*a0);
#line 3844 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_StringProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalStringProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getStringVectorProperty, "tlp.Graph.getStringVectorProperty(name)\n"
    "\n"
    "Returns the string vector property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the string vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.StringVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getStringVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getStringVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::StringVectorProperty *sipRes = 0;

#line 1988 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::StringVectorProperty>(*a0);
#line 3884 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_StringVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getStringVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalStringVectorProperty, "tlp.Graph.getLocalStringVectorProperty(name)\n"
    "\n"
    "Returns the string vector property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the string vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.StringVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalStringVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalStringVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::StringVectorProperty *sipRes = 0;

#line 2007 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::StringVectorProperty>(*a0);
#line 3924 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_StringVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalStringVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getSizeProperty, "tlp.Graph.getSizeProperty(name)\n"
    "\n"
    "Returns the size property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the size property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.SizeProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getSizeProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getSizeProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::SizeProperty *sipRes = 0;

#line 2026 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::SizeProperty>(*a0);
#line 3964 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_SizeProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getSizeProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalSizeProperty, "tlp.Graph.getLocalSizeProperty(name)\n"
    "\n"
    "Returns the size property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the size property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.SizeProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalSizeProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalSizeProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::SizeProperty *sipRes = 0;

#line 2045 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::SizeProperty>(*a0);
#line 4004 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_SizeProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalSizeProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getSizeVectorProperty, "tlp.Graph.getSizeVectorProperty(name)\n"
    "\n"
    "Returns the size vector property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the size vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.SizeVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getSizeVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getSizeVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::SizeVectorProperty *sipRes = 0;

#line 2064 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::SizeVectorProperty>(*a0);
#line 4044 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_SizeVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getSizeVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalSizeVectorProperty, "tlp.Graph.getLocalSizeVectorProperty(name)\n"
    "\n"
    "Returns the size vector property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the size vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.SizeVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalSizeVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalSizeVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::SizeVectorProperty *sipRes = 0;

#line 2083 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::SizeVectorProperty>(*a0);
#line 4084 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_SizeVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalSizeVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getIntegerProperty, "tlp.Graph.getIntegerProperty(name)\n"
    "\n"
    "Returns the integer property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the integer property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.IntegerProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getIntegerProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getIntegerProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::IntegerProperty *sipRes = 0;

#line 2102 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::IntegerProperty>(*a0);
#line 4124 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_IntegerProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getIntegerProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalIntegerProperty, "tlp.Graph.getLocalIntegerProperty(name)\n"
    "\n"
    "Returns the integer property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the integer property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.IntegerProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalIntegerProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalIntegerProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::IntegerProperty *sipRes = 0;

#line 2121 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::IntegerProperty>(*a0);
#line 4164 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_IntegerProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalIntegerProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getIntegerVectorProperty, "tlp.Graph.getIntegerVectorProperty(name)\n"
    "\n"
    "Returns the integer vector property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the integer vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.IntegerVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getIntegerVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getIntegerVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::IntegerVectorProperty *sipRes = 0;

#line 2140 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::IntegerVectorProperty>(*a0);
#line 4204 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_IntegerVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getIntegerVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalIntegerVectorProperty, "tlp.Graph.getLocalIntegerVectorProperty(name)\n"
    "\n"
    "Returns the integer vector property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the integer vector property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.IntegerVectorProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalIntegerVectorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalIntegerVectorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::IntegerVectorProperty *sipRes = 0;

#line 2159 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::IntegerVectorProperty>(*a0);
#line 4244 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_IntegerVectorProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalIntegerVectorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getGraphProperty, "tlp.Graph.getGraphProperty(name)\n"
    "\n"
    "Returns the meta-graph property associated to name in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the meta-graph property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.GraphProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getGraphProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getGraphProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::GraphProperty *sipRes = 0;

#line 2178 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getProperty<tlp::GraphProperty>(*a0);
#line 4284 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_GraphProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getGraphProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalGraphProperty, "tlp.Graph.getLocalGraphProperty(name)\n"
    "\n"
    "Returns the meta-graph property associated to name in the graph properties pool.\n"
    "If the property is not registered in the pool, it creates a new one and returns it. \n"
    "Using of :const:`del` on that property will cause a segmentation violation (use :meth:`tlp.Graph.delLocalProperty` instead). \n"
    "\n"
    ":param name: the name of the meta-graph property to return or to create\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.GraphProperty`");

extern "C" {static PyObject *meth_tlp_Graph_getLocalGraphProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalGraphProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::GraphProperty *sipRes = 0;

#line 2197 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = sipCpp->getLocalProperty<tlp::GraphProperty>(*a0);
#line 4324 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_GraphProperty,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalGraphProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getProperty, "tlp.Graph.getProperty(name)\n"
    "\n"
    "Returns the property associated to name in the graph properties pool.\n"
    "\n"
    ":param name: the name of the property to return\n"
    ":type name: string\n"
    ":rtype: a subclass of :class:`tlp.PropertyInterface`\n"
    ":throws: an exception is there is no property with that name in the properties pool.");

extern "C" {static PyObject *meth_tlp_Graph_getProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            tlp::PropertyInterface *sipRes = 0;
            int sipIsErr = 0;

#line 2215 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (sipCpp->existProperty(*a0)) {
        sipRes = sipCpp->getProperty(*a0);
    } else {
        std::ostringstream oss;
        oss << "graph property named \"" << *a0 << "\" does not exist.";
        sipIsErr = -1;
        PyErr_SetString(PyExc_Exception, oss.str().c_str());
    }
#line 4371 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_PropertyInterface,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_existProperty, "tlp.Graph.existProperty(name)\n"
    "\n"
    "Returns :const:`True` if a property of that name exists in the graph properties pool or in the pool of an ancestor in the sub-graphs hierarchy.\n"
    "\n"
    ":param name: the name of the property\n"
    ":type name: string\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_Graph_existProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_existProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            bool sipRes;

            sipRes = sipCpp->existProperty(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_existProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_existLocalProperty, "tlp.Graph.existLocalProperty(name)\n"
    "\n"
    "Returns :const:`True` if a property of that name exists in the graph properties pool.\n"
    "\n"
    ":param name: the name of the property\n"
    ":type name: string\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_Graph_existLocalProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_existLocalProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            bool sipRes;

            sipRes = sipCpp->existLocalProperty(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_existLocalProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_delLocalProperty, "tlp.Graph.delLocalProperty(name)\n"
    "\n"
    "Removes and deletes the property associated to name in the graph properties pool.\n"
    "\n"
    ":param name: the name of the property to delete\n"
    ":type name: string");

extern "C" {static PyObject *meth_tlp_Graph_delLocalProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_delLocalProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            int sipIsErr = 0;

#line 2264 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (sipCpp->existLocalProperty(*a0)) {
        tlp::PropertyInterface *prop = sipCpp->getProperty(*a0);
        releaseSIPWrapper(prop, sipType_tlp_PropertyInterface);
        sipCpp->delLocalProperty(*a0);
    } else {
        sipIsErr = 1;
        std::string msg = "No local graph property named  ";
        msg += *a0;
        msg += ".";
        PyErr_SetString(PyExc_Exception, msg.c_str());
    }
#line 4493 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_delLocalProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getLocalProperties, "tlp.Graph.getLocalProperties()\n"
    "\n"
    "Returns an iterator on the names of the properties local to the graph.\n"
    "\n"
    ":rtype: a Tulip iterator on string objects");

extern "C" {static PyObject *meth_tlp_Graph_getLocalProperties(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getLocalProperties(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::IteratorString *sipRes = 0;

#line 2288 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = new tlp::StableIterator<std::string>(sipCpp->getLocalProperties());
#line 4531 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            return sipConvertFromType(sipRes,sipType_tlp_IteratorString,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getLocalProperties, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getInheritedProperties, "tlp.Graph.getInheritedProperties()\n"
    "\n"
    "Returns an iterator on the names of the properties inherited from the graph's ancestors.\n"
    "\n"
    ":rtype: a Tulip iterator on string objects");

extern "C" {static PyObject *meth_tlp_Graph_getInheritedProperties(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getInheritedProperties(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::IteratorString *sipRes = 0;

#line 2303 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = new tlp::StableIterator<std::string>(sipCpp->getInheritedProperties());
#line 4564 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            return sipConvertFromType(sipRes,sipType_tlp_IteratorString,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getInheritedProperties, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getProperties, "tlp.Graph.getInheritedProperties()\n"
    "\n"
    "Returns an iterator on the names of all the properties attached to the graph.\n"
    "\n"
    ":rtype: a Tulip iterator on string objects");

extern "C" {static PyObject *meth_tlp_Graph_getProperties(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getProperties(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            tlp::IteratorString *sipRes = 0;

#line 2318 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	sipRes = new tlp::StableIterator<std::string>(sipCpp->getProperties());
#line 4597 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            return sipConvertFromType(sipRes,sipType_tlp_IteratorString,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getProperties, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_computeIntegerProperty, "tlp.Graph.computeIntegerProperty(algoName, result[, dataSet = None])\n"
    "\n"
    ".. deprecated:: 3.8 use :meth:`tlp.Graph.applyIntegerAlgorithm` instead\n"
    "\n"
    "Computes an integer property on the current graph \n"
    "using an external named integer algorithm (plugin).\n"
    "Integer algorithm plugins are objects\n"
    "implementing the tlp::IntegerAlgorithm interface in C++ or \n"
    "the :class:`tlp.IntegerAlgorithm` interface in Python.\n"
    "The list of currently loaded integer algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getIntegerAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the integer algorithm to call\n"
    ":type algoName: string\n"
    ":param result: an integer property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.IntegerProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested integer algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call integer algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_computeIntegerProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_computeIntegerProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::IntegerProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_IntegerProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2367 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Integer")) {
		tlp::IntegerProperty tmp(sipCpp);
		sipRes = sipCpp->computeProperty<tlp::IntegerProperty>(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip integer algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}
#line 4681 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_computeIntegerProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_applyIntegerAlgorithm, "tlp.Graph.applyIntegerAlgorithm(algoName, result[, dataSet = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes an integer property on the current graph \n"
    "using an external named integer algorithm (plugin).\n"
    "Integer algorithm plugins are objects\n"
    "implementing the tlp::IntegerAlgorithm interface in C++ or \n"
    "the :class:`tlp.IntegerAlgorithm` interface in Python.\n"
    "The list of currently loaded integer algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getIntegerAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the integer algorithm to call\n"
    ":type algoName: string\n"
    ":param result: an integer property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.IntegerProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested integer algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call integer algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_applyIntegerAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_applyIntegerAlgorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::IntegerProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_IntegerProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2426 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Integer")) {
		tlp::IntegerProperty tmp(sipCpp);
		sipRes = sipCpp->applyPropertyAlgorithm(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip integer algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}
#line 4769 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_applyIntegerAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_computeDoubleProperty, "tlp.Graph.computeDoubleProperty(algoName, result[, dataSet = None])\n"
    "\n"
    ".. deprecated:: 3.8 use :meth:`tlp.Graph.applyDoubleAlgorithm` instead\n"
    "\n"
    "Computes a double property on the current graph \n"
    "using an external named double algorithm (plugin).\n"
    "Double algorithm plugins are objects\n"
    "implementing the tlp::DoubleAlgorithm interface in C++ or \n"
    "the :class:`tlp.DoubleAlgorithm` interface in Python.\n"
    "The list of currently loaded double algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getDoubleAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the double algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a double property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.DoublrProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested double algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call double algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_computeDoubleProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_computeDoubleProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::DoubleProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_DoubleProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2484 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Double")) {
		tlp::DoubleProperty tmp(sipCpp);
		sipRes = sipCpp->computeProperty<tlp::DoubleProperty>(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip double algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 4856 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_computeDoubleProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_applyDoubleAlgorithm, "tlp.Graph.applyDoubleAlgorithm(algoName, result[, dataSet = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a double property on the current graph \n"
    "using an external named double algorithm (plugin).\n"
    "Double algorithm plugins are objects\n"
    "implementing the tlp::DoubleAlgorithm interface in C++ or \n"
    "the :class:`tlp.DoubleAlgorithm` interface in Python.\n"
    "The list of currently loaded double algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getDoubleAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the double algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a double property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.DoublrProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested double algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call double algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_applyDoubleAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_applyDoubleAlgorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::DoubleProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_DoubleProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2542 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Double")) {
		tlp::DoubleProperty tmp(sipCpp);
		sipRes = sipCpp->applyPropertyAlgorithm(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip double algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 4943 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_applyDoubleAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_computeLayoutProperty, "tlp.Graph.computeLayoutProperty(algoName, result[, dataSet = None])\n"
    "\n"
    ".. deprecated:: 3.8 use :meth:`tlp.Graph.applyLayoutAlgorithm` instead\n"
    "\n"
    "Computes a layout property on the current graph \n"
    "using an external named layout algorithm (plugin).\n"
    "Layout algorithm plugins are objects\n"
    "implementing the tlp::LayoutAlgorithm interface in C++ or \n"
    "the :class:`tlp.LayoutAlgorithm` interface in Python.\n"
    "The list of currently loaded layout algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getLayoutAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the layout algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a layout property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.LayoutProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested layout algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call layout algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_computeLayoutProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_computeLayoutProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::LayoutProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_LayoutProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2600 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Layout")) {
		tlp::LayoutProperty tmp(sipCpp);
		sipRes = sipCpp->computeProperty<tlp::LayoutProperty>(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip layout algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 5030 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_computeLayoutProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_applyLayoutAlgorithm, "tlp.Graph.applyLayoutAlgorithm(algoName, result[, dataSet = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a layout property on the current graph \n"
    "using an external named layout algorithm (plugin).\n"
    "Layout algorithm plugins are objects\n"
    "implementing the tlp::LayoutAlgorithm interface in C++ or \n"
    "the :class:`tlp.LayoutAlgorithm` interface in Python.\n"
    "The list of currently loaded layout algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getLayoutAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the layout algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a layout property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.LayoutProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested layout algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call layout algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_applyLayoutAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_applyLayoutAlgorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::LayoutProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_LayoutProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2658 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Layout")) {
		tlp::LayoutProperty tmp(sipCpp);
		sipRes = sipCpp->applyPropertyAlgorithm(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip layout algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 5117 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_applyLayoutAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_computeBooleanProperty, "tlp.Graph.computeBooleanProperty(algoName, result[, dataSet = None])\n"
    "\n"
    ".. deprecated:: 3.8 use :meth:`tlp.Graph.applyBooleanAlgorithm` instead\n"
    "\n"
    "Computes a boolean property on the current graph \n"
    "using an external named boolean algorithm (plugin).\n"
    "Boolean algorithm plugins are objects\n"
    "implementing the tlp::BooleanAlgorithm interface in C++ or \n"
    "the :class:`tlp.BooleanAlgorithm` interface in Python.\n"
    "The list of currently loaded boolean algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getBooleanAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the boolean algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a boolean property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.BooleanProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested boolean algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call boolean algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_computeBooleanProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_computeBooleanProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::BooleanProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_BooleanProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2717 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Boolean")) {
		tlp::BooleanProperty tmp(sipCpp);
		sipRes = sipCpp->computeProperty<tlp::BooleanProperty>(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip boolean algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}
#line 5205 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_computeBooleanProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_applyBooleanAlgorithm, "tlp.Graph.applyBooleanAlgorithm(algoName, result[, dataSet = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a boolean property on the current graph \n"
    "using an external named boolean algorithm (plugin).\n"
    "Boolean algorithm plugins are objects\n"
    "implementing the tlp::BooleanAlgorithm interface in C++ or \n"
    "the :class:`tlp.BooleanAlgorithm` interface in Python.\n"
    "The list of currently loaded boolean algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getBooleanAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the boolean algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a boolean property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.BooleanProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested boolean algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call boolean algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_applyBooleanAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_applyBooleanAlgorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::BooleanProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_BooleanProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2776 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Boolean")) {
		tlp::BooleanProperty tmp(sipCpp);
		sipRes = sipCpp->applyPropertyAlgorithm(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip boolean algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}
#line 5293 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_applyBooleanAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_computeSizeProperty, "tlp.Graph.computeSizeProperty(algoName, result[, dataSet = None])\n"
    "\n"
    ".. deprecated:: 3.8 use :meth:`tlp.Graph.applySizeAlgorithm` instead\n"
    "\n"
    "Computes a size property on the current graph \n"
    "using an external named size algorithm (plugin).\n"
    "Size algorithm plugins are objects\n"
    "implementing the tlp::SizeAlgorithm interface in C++ or \n"
    "the :class:`tlp.SizeAlgorithm` interface in Python.\n"
    "The list of currently loaded size algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getSizeAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the size algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a size property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.SizeProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested size algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call size algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_computeSizeProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_computeSizeProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::SizeProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_SizeProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2834 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Size")) {
		tlp::SizeProperty tmp(sipCpp);
		sipRes = sipCpp->computeProperty<tlp::SizeProperty>(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip size algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 5380 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_computeSizeProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_applySizeAlgorithm, "tlp.Graph.applySizeAlgorithm(algoName, result[, dataSet = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a size property on the current graph \n"
    "using an external named size algorithm (plugin).\n"
    "Size algorithm plugins are objects\n"
    "implementing the tlp::SizeAlgorithm interface in C++ or \n"
    "the :class:`tlp.SizeAlgorithm` interface in Python.\n"
    "The list of currently loaded size algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getSizeAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the size algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a size property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.SizeProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested size algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call size algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_applySizeAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_applySizeAlgorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::SizeProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_SizeProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2892 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Size")) {
		tlp::SizeProperty tmp(sipCpp);
		sipRes = sipCpp->applyPropertyAlgorithm(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip size algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 5467 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_applySizeAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_computeColorProperty, "tlp.Graph.computeColorProperty(algoName, result[, dataSet = None])\n"
    "\n"
    ".. deprecated:: 3.8 use :meth:`tlp.Graph.applyColorAlgorithm` instead\n"
    "\n"
    "Computes a color property on the current graph \n"
    "using an external named color algorithm (plugin).\n"
    "Color algorithm plugins are objects\n"
    "implementing the tlp::ColorAlgorithm interface in C++ or \n"
    "the :class:`tlp.ColorAlgorithm` interface in Python.\n"
    "The list of currently loaded color algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getColorAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the color algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a color property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.ColorProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested color algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call color algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_computeColorProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_computeColorProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::ColorProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_ColorProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 2950 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Color")) {
		tlp::ColorProperty tmp(sipCpp);
		sipRes = sipCpp->computeProperty<tlp::ColorProperty>(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip color algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 5554 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_computeColorProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_applyColorAlgorithm, "tlp.Graph.applyColorAlgorithm(algoName, result[, dataSet = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a color property on the current graph \n"
    "using an external named color algorithm (plugin).\n"
    "Color algorithm plugins are objects\n"
    "implementing the tlp::ColorAlgorithm interface in C++ or \n"
    "the :class:`tlp.ColorAlgorithm` interface in Python.\n"
    "The list of currently loaded color algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getColorAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the color algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a color property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.ColorProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested color algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call color algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_applyColorAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_applyColorAlgorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::ColorProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_ColorProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 3008 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Color")) {
		tlp::ColorProperty tmp(sipCpp);
		sipRes = sipCpp->applyPropertyAlgorithm(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip color algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 5641 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_applyColorAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_computeStringProperty, "tlp.Graph.computeStringProperty(algoName, result[, dataSet = None])\n"
    "\n"
    ".. deprecated:: 3.8 use :meth:`tlp.Graph.applyStringAlgorithm` instead\n"
    "\n"
    "Computes a string property on the current graph \n"
    "using an external named string algorithm (plugin).\n"
    "String algorithm plugins are objects\n"
    "implementing the tlp::StringAlgorithm interface in C++ or \n"
    "the :class:`tlp.StringAlgorithm` interface in Python.\n"
    "The list of currently loaded string algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getStringAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the string algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a string property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.StringProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested string algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call string algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_computeStringProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_computeStringProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::StringProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_StringProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 3066 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "String")) {
		tlp::StringProperty tmp(sipCpp);
		sipRes = sipCpp->computeProperty<tlp::StringProperty>(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip string algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}
#line 5728 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_computeStringProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_applyStringAlgorithm, "tlp.Graph.applyStringAlgorithm(algoName, result[, dataSet = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a string property on the current graph \n"
    "using an external named string algorithm (plugin).\n"
    "String algorithm plugins are objects\n"
    "implementing the tlp::StringAlgorithm interface in C++ or \n"
    "the :class:`tlp.StringAlgorithm` interface in Python.\n"
    "The list of currently loaded string algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getStringAlgorithmPluginsList` function.\n"
    "The computed values will be stored in result. \n"
    "Parameters can be transmit to the algorithm\n"
    "using a :class:`tlp.DataSet` . In some cases, algorithms \n"
    "can use this :class:`tlp.DataSet` in order to return some external information \n"
    "(not stored in result).\n"
    "To determine a plugin's parameters, you can either:\n"
    "    \n"
    "	* refer to its documentation\n"
    "	* call the :func:`tlp.getDefaultPluginParameters` with the name of the plugin\n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the \n"
    "algorithm terminates successfully and second member is a string \n"
    "which can contain an error message.\n"
    "\n"
    ":param algoName: the name of the string algorithm to call\n"
    ":type algoName: string\n"
    ":param result: a string property in which result of the algorithm will be stored\n"
    ":type result: :class:`tlp.StringProperty`\n"
    ":param dataSet: a data set containing some parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested string algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: Previous values stored in result will be deleted.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call string algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_Graph_applyStringAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_applyStringAlgorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::StringProperty * a1;
        std::string * a2;
        tlp::DataSet * a3 = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J8|J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, sipType_tlp_StringProperty, &a1, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            a2 = new std::string();
            int sipIsErr = 0;

#line 3124 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "String")) {
		tlp::StringProperty tmp(sipCpp);
		sipRes = sipCpp->applyPropertyAlgorithm(*a0, &tmp, *a2, NULL, a3);
		*a1 = tmp;
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip string algorithm plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}
#line 5815 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_applyStringAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_addGraphObserver, "tlp.Graph.addGraphObserver(graphObserver)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Registers a new graph observer object\n"
    "that will receive notifications when the graph is modified.\n"
    "\n"
    ":param graphObserver: the new graph observer to register\n"
    ":type graphObserver: :class:`tlp.GraphObserver`");

extern "C" {static PyObject *meth_tlp_Graph_addGraphObserver(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_addGraphObserver(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::GraphObserver * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_GraphObserver, &a0))
        {
            sipCpp->addGraphObserver(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_addGraphObserver, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_countGraphObservers, "tlp.Graph.countGraphObservers()\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Returns the number of registered graph observers.\n"
    "\n"
    ":rtype: integer");

extern "C" {static PyObject *meth_tlp_Graph_countGraphObservers(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_countGraphObservers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->countGraphObservers();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_countGraphObservers, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_removeGraphObserver, "tlp.Graph.removeGraphObserver(graphObserver)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Removes a registered graph observer object.\n"
    "\n"
    ":param graphObserver: the graph observer to remove\n"
    ":type graphObserver: :class:`tlp.GraphObserver`");

extern "C" {static PyObject *meth_tlp_Graph_removeGraphObserver(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_removeGraphObserver(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::GraphObserver * a0;
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_GraphObserver, &a0))
        {
            sipCpp->removeGraphObserver(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_removeGraphObserver, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_push, "tlp.Graph.push([unpopAllowed=True])\n"
    "\n"
    "Marks the state of the current root graph in the hierarchy.\n"
    "The next updates will be recorded in order to be undone at the\n"
    "next call of the :meth:`tlp.Graph.pop` method. Be careful that all \n"
    "the updates are undone except those who affect the ordering of edges.\n"
    "\n"
    ":param unpopAllowed: If set to :const:`False`, the next updates could not be replayed after undone. If some previously undonevupdates exist they could no longer be replayed.\n"
    ":type unpopAllowed: boolean");

extern "C" {static PyObject *meth_tlp_Graph_push(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_push(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0 = 1;
        std::vector<tlp::PropertyInterface *> * a1 = 0;
        int a1State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B|bJ0", &sipSelf, sipType_tlp_Graph, &sipCpp, &a0, sipType_std_vector_0101tlp_PropertyInterface,&a1, &a1State))
        {
            sipCpp->push(a0,a1);
            sipReleaseType(a1,sipType_std_vector_0101tlp_PropertyInterface,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_push, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_pop, "tlp.Graph.pop([unpopAllowed=True])\n"
    "\n"
    "Restores a previously marked state of the current root graph\n"
    "in the hierarchy. The restored state does not remain marked.\n"
    "\n"
    ":param unpopAllowed: If set to :const:`False`, the undone updates could not be replayed.\n"
    ":type unpopAllowed: boolean");

extern "C" {static PyObject *meth_tlp_Graph_pop(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_pop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0 = 1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B|b", &sipSelf, sipType_tlp_Graph, &sipCpp, &a0))
        {
            sipCpp->pop(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_pop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_unpop, "tlp.Graph.unpop()\n"
    "\n"
    "Marks again the current state of the root graph hierarchy\n"
    "and replays the last updates previously undone.");

extern "C" {static PyObject *meth_tlp_Graph_unpop(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_unpop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            sipCpp->unpop();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_unpop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_canPop, "tlp.Graph.canPop()\n"
    "\n"
    "Returns :const:`True` if a previously marked state can be restored.\n"
    "\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_Graph_canPop(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_canPop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->canPop();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_canPop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_canUnpop, "tlp.Graph.canUnpop()\n"
    "\n"
    "Returns :const:`True` if some previously undone updates can be replayed.\n"
    "\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_Graph_canUnpop(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_canUnpop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->canUnpop();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_canUnpop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_canPopThenUnpop, "tlp.Graph.canUnpop()\n"
    "\n"
    "Returns :const:`True` if the current state updates can be undone then replayed.\n"
    "\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_Graph_canPopThenUnpop(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_canPopThenUnpop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->canPopThenUnpop();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_canPopThenUnpop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_createMetaNode, "tlp.Graph.createMetaNode(nodeSet[, multiEdges=True, delAllEdge=True])\n"
    "\n"
    "Closes a set of existing nodes into a metanode and returns it.\n"
    "Edges from nodes in the set to other nodes are replaced with\n"
    "edges from the metanode to the other nodes.\n"
    "\n"
    ":param nodeSet: a set of existing nodes\n"
    ":type nodeSet: list of :class:`tlp.node`\n"
    ":param multiEdges: indicates if a meta edge will be created for each underlying edge\n"
    ":type multiEdges: boolean\n"
    ":param delAllEdge: indicates if the underlying edges will be removed from the entire hierarchy\n"
    ":type delAllEdge: boolean\n"
    ":rtype: :class:`tlp.node`\n"
    "\n"
    " .. warning:: This method will fail when called on the root graph.\n"
    "\n"
    "tlp.Graph.createMetaNode(subgraph[, multiEdges=True, delAllEdge=True])\n"
    "\n"
    "Closes an existing subgraph into a metanode and returns it.  Edges from nodes\n"
    "in the subgraph to nodes outside the subgraph are replaced with\n"
    "edges from the metanode to the nodes outside the subgraph.\n"
    "\n"
    ":param subgraph: an existing subgraph\n"
    ":type subgraph: :class:`tlp.Graph`\n"
    ":param multiEdges: indicates if a meta edge will be created for each underlying edge\n"
    ":type multiEdges: boolean\n"
    ":param delAllEdge: indicates if the underlying edges will be removed from the entire hierarchy\n"
    ":type delAllEdge: boolean\n"
    ":rtype: :class:`tlp.node`\n"
    "\n"
    ".. warning:: This method will fail when called on the root graph.\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_createMetaNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_createMetaNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::set<tlp::node> * a0;
        int a0State = 0;
        bool a1 = 1;
        bool a2 = 1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1|bb", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_set_0100tlp_node,&a0, &a0State, &a1, &a2))
        {
            tlp::node *sipRes;

            sipRes = new tlp::node(sipCpp->createMetaNode(*a0,a1,a2));
            sipReleaseType(const_cast<std::set<tlp::node> *>(a0),sipType_std_set_0100tlp_node,a0State);

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    {
        tlp::Graph * a0;
        bool a1 = 1;
        bool a2 = 1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8|bb", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_Graph, &a0, &a1, &a2))
        {
            tlp::node *sipRes;

            sipRes = new tlp::node(sipCpp->createMetaNode(a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_createMetaNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_createMetaNodes, "tlp.Graph.createMetaNodes(itGraph, quotientGraph)\n"
    "\n"
    "Populates a quotient graph with one meta node for each iterated graph.\n"
    "Returns a list of created meta-nodes.\n"
    "\n"
    ":param itGraph: a graph iterator, (typically a subgraph iterator)\n"
    ":type itGraph: a Tulip iterator on :class:`tlp.Graph` objects\n"
    ":param quotientGraph: the graph that will contain the meta nodes\n"
    ":type quotientGraph: :class:`tlp.Graph`\n"
    ":rtype: list of :class:`tlp.node`");

extern "C" {static PyObject *meth_tlp_Graph_createMetaNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_createMetaNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::IteratorGraph * a0;
        tlp::Graph * a1;
        std::vector<tlp::node> * a2;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J8", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_IteratorGraph, &a0, sipType_tlp_Graph, &a1))
        {
            a2 = new std::vector<tlp::node>();

            sipCpp->createMetaNodes(a0,a1,*a2);

            return sipConvertFromNewType(a2,sipType_std_vector_0100tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_createMetaNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_openMetaNode, "tlp.Graph.openMetaNode(metaNode[, updateProperties=True])\n"
    "\n"
    "Opens a metanode and replaces all edges between that\n"
    "meta node and other nodes in the graph.\n"
    "\n"
    ":param metaNode: the meta-node to open\n"
    ":type metaNode: :class:`tlp.node`\n"
    ":param updateProperties: If :const:`True`, open meta node will update inner nodes layout, color, size, etc...\n"
    ":type updateProperties: boolean\n"
    "\n"
    ".. warning:: This method will fail when called on the root graph.\n"
    "");

extern "C" {static PyObject *meth_tlp_Graph_openMetaNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_openMetaNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::node * a0;
        bool a1 = 1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9|b", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_tlp_node, &a0, &a1))
        {
            sipCpp->openMetaNode(*a0,a1);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_openMetaNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getName, "tlp.Graph.getName()\n"
    "\n"
    "Returns the name of the graph.\n"
    "\n"
    ":rtype: string");

extern "C" {static PyObject *meth_tlp_Graph_getName(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Graph, &sipCpp))
        {
            std::string *sipRes;

            sipRes = new std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getName, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_setName, "tlp.Graph.setName(name)\n"
    "\n"
    "Sets the name of the graph.\n"
    "\n"
    ":param name: the new name of the graph\n"
    ":type name: string");

extern "C" {static PyObject *meth_tlp_Graph_setName(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_setName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            sipCpp->setName(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_setName, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_setAttribute, "tlp.Graph.setAttribute(name, val)\n"
    "\n"
    "Sets an attribute of the graph.\n"
    "\n"
    ":param name: the name of the attribute to set\n"
    ":type name: string\n"
    ":param val: the value of the attribute\n"
    ":param type: object");

extern "C" {static PyObject *meth_tlp_Graph_setAttribute(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_setAttribute(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        PyObject * a1;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1P0", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State, &a1))
        {
            int sipIsErr = 0;

#line 3380 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
  int state=0, iserr=0;
  if (PyBool_Check(a1)) {
    long l = PyLong_AsLong(a1);
    sipCpp->setAttribute<bool>(*a0, (l > 0));
#if PY_MAJOR_VERSION < 3
  } else if (PyInt_CheckExact(a1)) {
    sipCpp->setAttribute(*a0, PyInt_AsLong(a1)); 
#endif
  } else if (PyLong_Check(a1)) {
    sipCpp->setAttribute(*a0, PyLong_AsLong(a1));
  } else if (PyFloat_Check(a1)) {
    sipCpp->setAttribute(*a0, PyFloat_AsDouble(a1));
  } else if (sipCanConvertToType(a1, sipType_std_string, SIP_NOT_NONE)) {   
    std::string *s = reinterpret_cast<std::string *>(sipConvertToType(a1, sipType_std_string, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *s); 
  } else if (sipCanConvertToType(a1, sipType_tlp_Coord, SIP_NOT_NONE)) {    
    tlp::Coord *c = reinterpret_cast<tlp::Coord *>(sipConvertToType(a1, sipType_tlp_Coord, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *c);
  } else if (sipCanConvertToType(a1, sipType_tlp_Color, SIP_NOT_NONE)) {    
    tlp::Color *c = reinterpret_cast<tlp::Color *>(sipConvertToType(a1, sipType_tlp_Color, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *c);
  } else if (sipCanConvertToType(a1, sipType_tlp_Size, SIP_NOT_NONE)) {   
    tlp::Size *s = reinterpret_cast<tlp::Size *>(sipConvertToType(a1, sipType_tlp_Size, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *s);
  } else if (sipCanConvertToType(a1, sipType_tlp_DataSet, SIP_NOT_NONE)) {    
    tlp::DataSet *ds = reinterpret_cast<tlp::DataSet *>(sipConvertToType(a1, sipType_tlp_DataSet, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *ds);  
  } else if (sipCanConvertToType(a1, sipType_tlp_ColorScale, SIP_NOT_NONE)) {   
    tlp::ColorScale *cs = reinterpret_cast<tlp::ColorScale *>(sipConvertToType(a1, sipType_tlp_ColorScale, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *cs);
  } else if (sipCanConvertToType(a1, sipType_tlp_StringCollection, SIP_NOT_NONE)) {   
    tlp::StringCollection *sc = reinterpret_cast<tlp::StringCollection *>(sipConvertToType(a1, sipType_tlp_StringCollection, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *sc);    
  } else if (sipCanConvertToType(a1, sipType_tlp_BooleanProperty, SIP_NOT_NONE)) {    
    tlp::BooleanProperty *p = reinterpret_cast<tlp::BooleanProperty *>(sipConvertToType(a1, sipType_tlp_BooleanProperty, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, p);
  } else if (sipCanConvertToType(a1, sipType_tlp_ColorProperty, SIP_NOT_NONE)) {    
    tlp::ColorProperty *p = reinterpret_cast<tlp::ColorProperty *>(sipConvertToType(a1, sipType_tlp_ColorProperty, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, p);
  } else if (sipCanConvertToType(a1, sipType_tlp_DoubleProperty, SIP_NOT_NONE)) {   
    tlp::DoubleProperty *p = reinterpret_cast<tlp::DoubleProperty *>(sipConvertToType(a1, sipType_tlp_DoubleProperty, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, p);
  } else if (sipCanConvertToType(a1, sipType_tlp_IntegerProperty, SIP_NOT_NONE)) {    
    tlp::IntegerProperty *p = reinterpret_cast<tlp::IntegerProperty *>(sipConvertToType(a1, sipType_tlp_IntegerProperty, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, p);
  } else if (sipCanConvertToType(a1, sipType_tlp_LayoutProperty, SIP_NOT_NONE)) {   
    tlp::LayoutProperty *p = reinterpret_cast<tlp::LayoutProperty *>(sipConvertToType(a1, sipType_tlp_LayoutProperty, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, p);
  } else if (sipCanConvertToType(a1, sipType_tlp_SizeProperty, SIP_NOT_NONE)) {   
    tlp::SizeProperty *p = reinterpret_cast<tlp::SizeProperty *>(sipConvertToType(a1, sipType_tlp_SizeProperty, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, p);
  } else if (sipCanConvertToType(a1, sipType_tlp_StringProperty, SIP_NOT_NONE)) {   
    tlp::StringProperty *p = reinterpret_cast<tlp::StringProperty *>(sipConvertToType(a1, sipType_tlp_StringProperty, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, p);              
  } else if (sipCanConvertToType(a1, sipType_tlp_PropertyInterface, SIP_NOT_NONE)) {    
    tlp::PropertyInterface *p = reinterpret_cast<tlp::PropertyInterface *>(sipConvertToType(a1, sipType_tlp_PropertyInterface, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, p);
  } else if (sipCanConvertToType(a1, sipType_std_vector_0100tlp_node, SIP_NOT_NONE)) {    
    std::vector<tlp::node> *p = reinterpret_cast<std::vector<tlp::node> *>(sipConvertToType(a1, sipType_std_vector_0100tlp_node, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *p);
  } else if (sipCanConvertToType(a1, sipType_std_vector_0100tlp_edge, SIP_NOT_NONE)) {    
    std::vector<tlp::edge> *p = reinterpret_cast<std::vector<tlp::edge> *>(sipConvertToType(a1, sipType_std_vector_0100tlp_edge, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *p);
  } else if (sipCanConvertToType(a1, sipType_std_vector_0100tlp_Coord, SIP_NOT_NONE)) {    
    std::vector<tlp::Coord> *p = reinterpret_cast<std::vector<tlp::Coord> *>(sipConvertToType(a1, sipType_std_vector_0100tlp_Coord, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *p);
  } else if (sipCanConvertToType(a1, sipType_std_vector_0100tlp_Color, SIP_NOT_NONE)) {    
    std::vector<tlp::Color> *p = reinterpret_cast<std::vector<tlp::Color> *>(sipConvertToType(a1, sipType_std_vector_0100tlp_Color, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *p);
  } else if (sipCanConvertToType(a1, sipType_std_vector_0100tlp_Size, SIP_NOT_NONE)) {    
    std::vector<tlp::Size> *p = reinterpret_cast<std::vector<tlp::Size> *>(sipConvertToType(a1, sipType_std_vector_0100tlp_Size, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *p);
  } else if (sipCanConvertToType(a1, sipType_std_vector_0100std_string, SIP_NOT_NONE)) {
    std::vector<std::string> *p = reinterpret_cast<std::vector<std::string> *>(sipConvertToType(a1, sipType_std_vector_0100std_string, NULL, SIP_NOT_NONE, &state, &iserr));
    sipCpp->setAttribute(*a0, *p);
  } else {
  	sipIsErr = 1;
	std::string msg = "Object of type ";
	msg += std::string(a1->ob_type->tp_name);
	msg += " can not be store as graph attribute.";
	PyErr_SetString(PyExc_Exception, msg.c_str());
  }
#line 6456 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_setAttribute, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Graph_getAttribute, "tlp.Graph.getAttribute(name)\n"
    "\n"
    "Returns a reference on an attribute of the graph or :const:`None` if it does not exist.\n"
    "\n"
    ":param name: the name of the attribute to return.\n"
    ":type name: string\n"
    ":rtype: object");

extern "C" {static PyObject *meth_tlp_Graph_getAttribute(PyObject *, PyObject *);}
static PyObject *meth_tlp_Graph_getAttribute(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_Graph, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 3479 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
bool ok = false;
if (sipCpp->getAttributes().exist(*a0)) {
  tlp::DataType* dataType = sipCpp->getAttribute(*a0);
  if (dataType->getTypeName() == std::string(typeid(bool).name())) {
    ok = true;
    sipRes = PyBool_FromLong(*(reinterpret_cast<bool*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(int).name())) {
    ok = true;
    sipRes = PyLong_FromLong(*(reinterpret_cast<int*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(long).name())) {
    ok = true;
    sipRes = PyLong_FromLong(*(reinterpret_cast<long*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(short).name())) {
    ok = true;
    sipRes = PyLong_FromLong(*(reinterpret_cast<short*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(unsigned int).name())) {
    ok = true;
    sipRes = PyLong_FromUnsignedLong(*(reinterpret_cast<unsigned int*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(unsigned long).name())) {
    ok = true;
    sipRes = PyLong_FromUnsignedLong(*(reinterpret_cast<unsigned long*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(unsigned short).name())) {
    ok = true;
    sipRes = PyLong_FromUnsignedLong(*(reinterpret_cast<unsigned short*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(double).name())) {
    ok = true;
    sipRes = PyFloat_FromDouble(*(reinterpret_cast<double*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(float).name())) {
    ok = true;
    sipRes = PyFloat_FromDouble(*(reinterpret_cast<float*>(dataType->value)));
    
  } else if (dataType->getTypeName() == std::string(typeid(std::string).name())) {
    ok = true;
#if PY_MAJOR_VERSION >= 3
    sipRes = PyUnicode_FromString((*(reinterpret_cast<std::string*>(dataType->value))).c_str());
#else
    sipRes = PyString_FromString((*(reinterpret_cast<std::string*>(dataType->value))).c_str());
#endif
  } else if (dataType->getTypeName() == std::string(typeid(tlp::DataSet).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<tlp::DataSet *>(dataType->value), sipType_tlp_DataSet, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::DataSet).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<tlp::DataSet *>(dataType->value), sipType_tlp_DataSet, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::Coord).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<tlp::Coord *>(dataType->value), sipType_tlp_Coord, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::Color).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<tlp::Color *>(dataType->value), sipType_tlp_Color, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::Size).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<tlp::Size *>(dataType->value), sipType_tlp_Size, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::ColorScale).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<tlp::ColorScale *>(dataType->value), sipType_tlp_ColorScale, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::StringCollection).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<tlp::StringCollection *>(dataType->value), sipType_tlp_StringCollection, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::PropertyInterface*).name())) {
    ok = true;
    sipRes = sipConvertFromType(*(reinterpret_cast<tlp::PropertyInterface **>(dataType->value)), sipType_tlp_PropertyInterface, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::BooleanProperty*).name())) {
    ok = true;
    sipRes = sipConvertFromType(*(reinterpret_cast<tlp::BooleanProperty **>(dataType->value)), sipType_tlp_BooleanProperty, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::ColorProperty*).name())) {
    ok = true;
    sipRes = sipConvertFromType(*(reinterpret_cast<tlp::ColorProperty **>(dataType->value)), sipType_tlp_ColorProperty, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::DoubleProperty*).name())) {
    ok = true;
    sipRes = sipConvertFromType(*(reinterpret_cast<tlp::DoubleProperty **>(dataType->value)), sipType_tlp_DoubleProperty, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::IntegerProperty*).name())) {
    ok = true;
    sipRes = sipConvertFromType(*(reinterpret_cast<tlp::IntegerProperty **>(dataType->value)), sipType_tlp_IntegerProperty, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::LayoutProperty*).name())) {
    ok = true;
    sipRes = sipConvertFromType(*(reinterpret_cast<tlp::LayoutProperty **>(dataType->value)), sipType_tlp_LayoutProperty, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::SizeProperty*).name())) {
    ok = true;
    sipRes = sipConvertFromType(*(reinterpret_cast<tlp::SizeProperty **>(dataType->value)), sipType_tlp_SizeProperty, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(tlp::StringProperty*).name())) {
    ok = true;
    sipRes = sipConvertFromType(*(reinterpret_cast<tlp::StringProperty **>(dataType->value)), sipType_tlp_StringProperty, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(std::vector<tlp::node>).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<std::vector<tlp::node> *>(dataType->value), sipType_std_vector_0100tlp_node, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(std::set<tlp::node>).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<std::set<tlp::node> *>(dataType->value), sipType_std_set_0100tlp_node, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(std::vector<tlp::edge>).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<std::vector<tlp::edge> *>(dataType->value), sipType_std_vector_0100tlp_edge, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(std::set<tlp::edge>).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<std::set<tlp::edge> *>(dataType->value), sipType_std_set_0100tlp_edge, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(std::vector<tlp::Coord>).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<std::vector<tlp::Coord> *>(dataType->value), sipType_std_vector_0100tlp_Coord, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(std::vector<tlp::Color>).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<std::vector<tlp::Color> *>(dataType->value), sipType_std_vector_0100tlp_Color, NULL);
    
  } else if (dataType->getTypeName() == std::string(typeid(std::vector<tlp::Size>).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<std::vector<tlp::Size> *>(dataType->value), sipType_std_vector_0100tlp_Size, NULL);
  } else if (dataType->getTypeName() == std::string(typeid(std::vector<std::string>).name())) {
    ok = true;
    sipRes = sipConvertFromType(reinterpret_cast<std::vector<std::string> *>(dataType->value), sipType_std_vector_0100std_string, NULL);
  }
  delete dataType;
}

if (!ok) {
	std::ostringstream oss;
  	oss << "Graph attribute named \"" << *a0 << "\" does not exist.";
  	sipRes = NULL;
  	sipIsErr = 1;
  	PyErr_SetString(PyExc_AttributeError, oss.str().c_str());
}
#line 6645 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName_getAttribute, NULL);

    return NULL;
}


extern "C" {static long slot_tlp_Graph___hash__(PyObject *);}
static long slot_tlp_Graph___hash__(PyObject *sipSelf)
{
    tlp::Graph *sipCpp = reinterpret_cast<tlp::Graph *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_tlp_Graph));

    if (!sipCpp)
        return 0;


    {
        {
            long sipRes = 0;

#line 3648 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
        return static_cast<long>(sipCpp->getId());
#line 6677 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_tlp_Graph___repr__(PyObject *);}
static PyObject *slot_tlp_Graph___repr__(PyObject *sipSelf)
{
    tlp::Graph *sipCpp = reinterpret_cast<tlp::Graph *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_tlp_Graph));

    if (!sipCpp)
        return 0;


    {
        {
            PyObject * sipRes = 0;

#line 3632 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
	std::string graphName;
	sipCpp->getAttribute("name", graphName);
	std::ostringstream oss;
	oss << "<graph \"" << graphName << "\" (id " << sipCpp->getId() << ") >";
	std::string s = oss.str();
#if PY_MAJOR_VERSION >= 3
    sipRes = PyUnicode_FromString(s.c_str());
#else
    sipRes = PyString_FromString(s.c_str());
#endif
#line 6711 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_tlp_Graph___getitem__(PyObject *,PyObject *);}
static PyObject *slot_tlp_Graph___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
    tlp::Graph *sipCpp = reinterpret_cast<tlp::Graph *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_tlp_Graph));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_std_string,&a0, &a0State))
        {
            tlp::PropertyInterface *sipRes = 0;
            int sipIsErr = 0;

#line 3332 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
        if (sipCpp->existProperty(*a0)) {
            sipRes = sipCpp->getProperty(*a0);
        } else {
        	std::ostringstream oss;
        	oss << "graph property named \"" << *a0 << "\" does not exist.";
			sipIsErr = -1;    
        	PyErr_SetString(PyExc_Exception, oss.str().c_str());
        }
#line 6749 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraph.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_PropertyInterface,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Graph, sipName___getitem__, NULL);

    return 0;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_tlp_Graph(void *, const sipTypeDef *);}
static void *cast_tlp_Graph(void *ptr, const sipTypeDef *targetType)
{
    void *res;

    if (targetType == sipType_tlp_Graph)
        return ptr;

    if ((res = ((const sipClassTypeDef *)sipType_tlp_Observable)->ctd_cast((tlp::Observable *)(tlp::Graph *)ptr,targetType)) != NULL)
        return res;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_tlp_Graph(void *, int);}
static void release_tlp_Graph(void *sipCppV,int)
{
    delete reinterpret_cast<tlp::Graph *>(sipCppV);
}


extern "C" {static void dealloc_tlp_Graph(sipSimpleWrapper *);}
static void dealloc_tlp_Graph(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_tlp_Graph(sipGetAddress(sipSelf),0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_tlp_Graph[] = {{78, 255, 1}};


/* Define this type's Python slots. */
static sipPySlotDef slots_tlp_Graph[] = {
    {(void *)slot_tlp_Graph___hash__, hash_slot},
    {(void *)slot_tlp_Graph___repr__, repr_slot},
    {(void *)slot_tlp_Graph___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_tlp_Graph[] = {
    {SIP_MLNAME_CAST(sipName_addCloneSubGraph), meth_tlp_Graph_addCloneSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_addCloneSubGraph)},
    {SIP_MLNAME_CAST(sipName_addEdge), meth_tlp_Graph_addEdge, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_addEdge)},
    {SIP_MLNAME_CAST(sipName_addEdges), meth_tlp_Graph_addEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_addEdges)},
    {SIP_MLNAME_CAST(sipName_addGraphObserver), meth_tlp_Graph_addGraphObserver, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_addGraphObserver)},
    {SIP_MLNAME_CAST(sipName_addNode), meth_tlp_Graph_addNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_addNode)},
    {SIP_MLNAME_CAST(sipName_addNodes), meth_tlp_Graph_addNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_addNodes)},
    {SIP_MLNAME_CAST(sipName_addSubGraph), meth_tlp_Graph_addSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_addSubGraph)},
    {SIP_MLNAME_CAST(sipName_applyAlgorithm), meth_tlp_Graph_applyAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_applyAlgorithm)},
    {SIP_MLNAME_CAST(sipName_applyBooleanAlgorithm), meth_tlp_Graph_applyBooleanAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_applyBooleanAlgorithm)},
    {SIP_MLNAME_CAST(sipName_applyColorAlgorithm), meth_tlp_Graph_applyColorAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_applyColorAlgorithm)},
    {SIP_MLNAME_CAST(sipName_applyDoubleAlgorithm), meth_tlp_Graph_applyDoubleAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_applyDoubleAlgorithm)},
    {SIP_MLNAME_CAST(sipName_applyIntegerAlgorithm), meth_tlp_Graph_applyIntegerAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_applyIntegerAlgorithm)},
    {SIP_MLNAME_CAST(sipName_applyLayoutAlgorithm), meth_tlp_Graph_applyLayoutAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_applyLayoutAlgorithm)},
    {SIP_MLNAME_CAST(sipName_applySizeAlgorithm), meth_tlp_Graph_applySizeAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_applySizeAlgorithm)},
    {SIP_MLNAME_CAST(sipName_applyStringAlgorithm), meth_tlp_Graph_applyStringAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_applyStringAlgorithm)},
    {SIP_MLNAME_CAST(sipName_canPop), meth_tlp_Graph_canPop, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_canPop)},
    {SIP_MLNAME_CAST(sipName_canPopThenUnpop), meth_tlp_Graph_canPopThenUnpop, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_canPopThenUnpop)},
    {SIP_MLNAME_CAST(sipName_canUnpop), meth_tlp_Graph_canUnpop, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_canUnpop)},
    {SIP_MLNAME_CAST(sipName_clear), meth_tlp_Graph_clear, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_clear)},
    {SIP_MLNAME_CAST(sipName_computeBooleanProperty), meth_tlp_Graph_computeBooleanProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_computeBooleanProperty)},
    {SIP_MLNAME_CAST(sipName_computeColorProperty), meth_tlp_Graph_computeColorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_computeColorProperty)},
    {SIP_MLNAME_CAST(sipName_computeDoubleProperty), meth_tlp_Graph_computeDoubleProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_computeDoubleProperty)},
    {SIP_MLNAME_CAST(sipName_computeIntegerProperty), meth_tlp_Graph_computeIntegerProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_computeIntegerProperty)},
    {SIP_MLNAME_CAST(sipName_computeLayoutProperty), meth_tlp_Graph_computeLayoutProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_computeLayoutProperty)},
    {SIP_MLNAME_CAST(sipName_computeSizeProperty), meth_tlp_Graph_computeSizeProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_computeSizeProperty)},
    {SIP_MLNAME_CAST(sipName_computeStringProperty), meth_tlp_Graph_computeStringProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_computeStringProperty)},
    {SIP_MLNAME_CAST(sipName_countGraphObservers), meth_tlp_Graph_countGraphObservers, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_countGraphObservers)},
    {SIP_MLNAME_CAST(sipName_createMetaNode), meth_tlp_Graph_createMetaNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_createMetaNode)},
    {SIP_MLNAME_CAST(sipName_createMetaNodes), meth_tlp_Graph_createMetaNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_createMetaNodes)},
    {SIP_MLNAME_CAST(sipName_deg), meth_tlp_Graph_deg, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_deg)},
    {SIP_MLNAME_CAST(sipName_delAllSubGraphs), meth_tlp_Graph_delAllSubGraphs, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_delAllSubGraphs)},
    {SIP_MLNAME_CAST(sipName_delEdge), meth_tlp_Graph_delEdge, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_delEdge)},
    {SIP_MLNAME_CAST(sipName_delEdges), meth_tlp_Graph_delEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_delEdges)},
    {SIP_MLNAME_CAST(sipName_delLocalProperty), meth_tlp_Graph_delLocalProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_delLocalProperty)},
    {SIP_MLNAME_CAST(sipName_delNode), meth_tlp_Graph_delNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_delNode)},
    {SIP_MLNAME_CAST(sipName_delNodes), meth_tlp_Graph_delNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_delNodes)},
    {SIP_MLNAME_CAST(sipName_delSubGraph), meth_tlp_Graph_delSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_delSubGraph)},
    {SIP_MLNAME_CAST(sipName_ends), meth_tlp_Graph_ends, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_ends)},
    {SIP_MLNAME_CAST(sipName_existEdge), meth_tlp_Graph_existEdge, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_existEdge)},
    {SIP_MLNAME_CAST(sipName_existLocalProperty), meth_tlp_Graph_existLocalProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_existLocalProperty)},
    {SIP_MLNAME_CAST(sipName_existProperty), meth_tlp_Graph_existProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_existProperty)},
    {SIP_MLNAME_CAST(sipName_getAttribute), meth_tlp_Graph_getAttribute, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getAttribute)},
    {SIP_MLNAME_CAST(sipName_getBooleanProperty), meth_tlp_Graph_getBooleanProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getBooleanProperty)},
    {SIP_MLNAME_CAST(sipName_getBooleanVectorProperty), meth_tlp_Graph_getBooleanVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getBooleanVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getColorProperty), meth_tlp_Graph_getColorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getColorProperty)},
    {SIP_MLNAME_CAST(sipName_getColorVectorProperty), meth_tlp_Graph_getColorVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getColorVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getCoordVectorProperty), meth_tlp_Graph_getCoordVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getCoordVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getDescendantGraph), meth_tlp_Graph_getDescendantGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getDescendantGraph)},
    {SIP_MLNAME_CAST(sipName_getDoubleProperty), meth_tlp_Graph_getDoubleProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getDoubleProperty)},
    {SIP_MLNAME_CAST(sipName_getDoubleVectorProperty), meth_tlp_Graph_getDoubleVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getDoubleVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getEdgeMetaInfo), meth_tlp_Graph_getEdgeMetaInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getEdgeMetaInfo)},
    {SIP_MLNAME_CAST(sipName_getEdges), meth_tlp_Graph_getEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getEdges)},
    {SIP_MLNAME_CAST(sipName_getGraphProperty), meth_tlp_Graph_getGraphProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getGraphProperty)},
    {SIP_MLNAME_CAST(sipName_getId), meth_tlp_Graph_getId, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getId)},
    {SIP_MLNAME_CAST(sipName_getInEdges), meth_tlp_Graph_getInEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getInEdges)},
    {SIP_MLNAME_CAST(sipName_getInNode), meth_tlp_Graph_getInNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getInNode)},
    {SIP_MLNAME_CAST(sipName_getInNodes), meth_tlp_Graph_getInNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getInNodes)},
    {SIP_MLNAME_CAST(sipName_getInOutEdges), meth_tlp_Graph_getInOutEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getInOutEdges)},
    {SIP_MLNAME_CAST(sipName_getInOutNodes), meth_tlp_Graph_getInOutNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getInOutNodes)},
    {SIP_MLNAME_CAST(sipName_getInheritedProperties), meth_tlp_Graph_getInheritedProperties, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getInheritedProperties)},
    {SIP_MLNAME_CAST(sipName_getIntegerProperty), meth_tlp_Graph_getIntegerProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getIntegerProperty)},
    {SIP_MLNAME_CAST(sipName_getIntegerVectorProperty), meth_tlp_Graph_getIntegerVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getIntegerVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getLayoutProperty), meth_tlp_Graph_getLayoutProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLayoutProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalBooleanProperty), meth_tlp_Graph_getLocalBooleanProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalBooleanProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalBooleanVectorProperty), meth_tlp_Graph_getLocalBooleanVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalBooleanVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalColorProperty), meth_tlp_Graph_getLocalColorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalColorProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalColorVectorProperty), meth_tlp_Graph_getLocalColorVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalColorVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalCoordVectorProperty), meth_tlp_Graph_getLocalCoordVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalCoordVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalDoubleProperty), meth_tlp_Graph_getLocalDoubleProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalDoubleProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalDoubleVectorProperty), meth_tlp_Graph_getLocalDoubleVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalDoubleVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalGraphProperty), meth_tlp_Graph_getLocalGraphProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalGraphProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalIntegerProperty), meth_tlp_Graph_getLocalIntegerProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalIntegerProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalIntegerVectorProperty), meth_tlp_Graph_getLocalIntegerVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalIntegerVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalLayoutProperty), meth_tlp_Graph_getLocalLayoutProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalLayoutProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalProperties), meth_tlp_Graph_getLocalProperties, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalProperties)},
    {SIP_MLNAME_CAST(sipName_getLocalSizeProperty), meth_tlp_Graph_getLocalSizeProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalSizeProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalSizeVectorProperty), meth_tlp_Graph_getLocalSizeVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalSizeVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalStringProperty), meth_tlp_Graph_getLocalStringProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalStringProperty)},
    {SIP_MLNAME_CAST(sipName_getLocalStringVectorProperty), meth_tlp_Graph_getLocalStringVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getLocalStringVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getName), meth_tlp_Graph_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getName)},
    {SIP_MLNAME_CAST(sipName_getNodeMetaInfo), meth_tlp_Graph_getNodeMetaInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getNodeMetaInfo)},
    {SIP_MLNAME_CAST(sipName_getNodes), meth_tlp_Graph_getNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getNodes)},
    {SIP_MLNAME_CAST(sipName_getNthSubGraph), meth_tlp_Graph_getNthSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getNthSubGraph)},
    {SIP_MLNAME_CAST(sipName_getOneEdge), meth_tlp_Graph_getOneEdge, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getOneEdge)},
    {SIP_MLNAME_CAST(sipName_getOneNode), meth_tlp_Graph_getOneNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getOneNode)},
    {SIP_MLNAME_CAST(sipName_getOutEdges), meth_tlp_Graph_getOutEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getOutEdges)},
    {SIP_MLNAME_CAST(sipName_getOutNode), meth_tlp_Graph_getOutNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getOutNode)},
    {SIP_MLNAME_CAST(sipName_getOutNodes), meth_tlp_Graph_getOutNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getOutNodes)},
    {SIP_MLNAME_CAST(sipName_getProperties), meth_tlp_Graph_getProperties, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getProperties)},
    {SIP_MLNAME_CAST(sipName_getProperty), meth_tlp_Graph_getProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getProperty)},
    {SIP_MLNAME_CAST(sipName_getRoot), meth_tlp_Graph_getRoot, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getRoot)},
    {SIP_MLNAME_CAST(sipName_getSizeProperty), meth_tlp_Graph_getSizeProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getSizeProperty)},
    {SIP_MLNAME_CAST(sipName_getSizeVectorProperty), meth_tlp_Graph_getSizeVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getSizeVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getSource), meth_tlp_Graph_getSource, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getSource)},
    {SIP_MLNAME_CAST(sipName_getStringProperty), meth_tlp_Graph_getStringProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getStringProperty)},
    {SIP_MLNAME_CAST(sipName_getStringVectorProperty), meth_tlp_Graph_getStringVectorProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getStringVectorProperty)},
    {SIP_MLNAME_CAST(sipName_getSubGraph), meth_tlp_Graph_getSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getSubGraph)},
    {SIP_MLNAME_CAST(sipName_getSubGraphs), meth_tlp_Graph_getSubGraphs, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getSubGraphs)},
    {SIP_MLNAME_CAST(sipName_getSuperGraph), meth_tlp_Graph_getSuperGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_getSuperGraph)},
    {SIP_MLNAME_CAST(sipName_indeg), meth_tlp_Graph_indeg, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_indeg)},
    {SIP_MLNAME_CAST(sipName_inducedSubGraph), meth_tlp_Graph_inducedSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_inducedSubGraph)},
    {SIP_MLNAME_CAST(sipName_isDescendantGraph), meth_tlp_Graph_isDescendantGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_isDescendantGraph)},
    {SIP_MLNAME_CAST(sipName_isElement), meth_tlp_Graph_isElement, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_isElement)},
    {SIP_MLNAME_CAST(sipName_isMetaEdge), meth_tlp_Graph_isMetaEdge, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_isMetaEdge)},
    {SIP_MLNAME_CAST(sipName_isMetaNode), meth_tlp_Graph_isMetaNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_isMetaNode)},
    {SIP_MLNAME_CAST(sipName_isSubGraph), meth_tlp_Graph_isSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_isSubGraph)},
    {SIP_MLNAME_CAST(sipName_numberOfDescendantGraphs), meth_tlp_Graph_numberOfDescendantGraphs, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_numberOfDescendantGraphs)},
    {SIP_MLNAME_CAST(sipName_numberOfEdges), meth_tlp_Graph_numberOfEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_numberOfEdges)},
    {SIP_MLNAME_CAST(sipName_numberOfNodes), meth_tlp_Graph_numberOfNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_numberOfNodes)},
    {SIP_MLNAME_CAST(sipName_numberOfSubGraphs), meth_tlp_Graph_numberOfSubGraphs, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_numberOfSubGraphs)},
    {SIP_MLNAME_CAST(sipName_openMetaNode), meth_tlp_Graph_openMetaNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_openMetaNode)},
    {SIP_MLNAME_CAST(sipName_opposite), meth_tlp_Graph_opposite, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_opposite)},
    {SIP_MLNAME_CAST(sipName_outdeg), meth_tlp_Graph_outdeg, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_outdeg)},
    {SIP_MLNAME_CAST(sipName_pop), meth_tlp_Graph_pop, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_pop)},
    {SIP_MLNAME_CAST(sipName_push), meth_tlp_Graph_push, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_push)},
    {SIP_MLNAME_CAST(sipName_removeGraphObserver), meth_tlp_Graph_removeGraphObserver, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_removeGraphObserver)},
    {SIP_MLNAME_CAST(sipName_reverse), meth_tlp_Graph_reverse, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_reverse)},
    {SIP_MLNAME_CAST(sipName_setAttribute), meth_tlp_Graph_setAttribute, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_setAttribute)},
    {SIP_MLNAME_CAST(sipName_setEdgeOrder), meth_tlp_Graph_setEdgeOrder, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_setEdgeOrder)},
    {SIP_MLNAME_CAST(sipName_setEnds), meth_tlp_Graph_setEnds, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_setEnds)},
    {SIP_MLNAME_CAST(sipName_setName), meth_tlp_Graph_setName, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_setName)},
    {SIP_MLNAME_CAST(sipName_setSource), meth_tlp_Graph_setSource, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_setSource)},
    {SIP_MLNAME_CAST(sipName_setSuperGraph), meth_tlp_Graph_setSuperGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_setSuperGraph)},
    {SIP_MLNAME_CAST(sipName_setTarget), meth_tlp_Graph_setTarget, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_setTarget)},
    {SIP_MLNAME_CAST(sipName_source), meth_tlp_Graph_source, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_source)},
    {SIP_MLNAME_CAST(sipName_swapEdgeOrder), meth_tlp_Graph_swapEdgeOrder, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_swapEdgeOrder)},
    {SIP_MLNAME_CAST(sipName_target), meth_tlp_Graph_target, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_target)},
    {SIP_MLNAME_CAST(sipName_unpop), meth_tlp_Graph_unpop, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Graph_unpop)}
};

PyDoc_STRVAR(doc_tlp_Graph, "This is the main Tulip class. It enables to :\n"
    "\n"
    "	* create a directed graph\n"
    "	* create and manipulate a sub-graphs hierarchy\n"
    "	* get semantic iterators on graph elements\n"
    "	* create and retrieve properties of different types to get/set data on the graph\n"
    "	\n"
    "This class can not be instanced directly. Use :func:`tlp.newGraph()` to create a new\n"
    "empty graph.	");


sipClassTypeDef sipTypeDef_tulip_tlp_Graph = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_tlp__Graph,
        {0}
    },
    {
        sipNameNr_Graph,
        {21, 255, 0},
        128, methods_tlp_Graph,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_tlp_Graph,
    -1,
    -1,
    supers_tlp_Graph,
    slots_tlp_Graph,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_tlp_Graph,
    0,
    0,
    0,
    release_tlp_Graph,
    cast_tlp_Graph,
    0,
    0,
    0
};

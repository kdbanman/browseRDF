/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Fri Apr 26 16:33:30 2013
 */

#include "sipAPItulip.h"

#line 29 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/Algorithm.sip"
#include <tulip/Algorithm.h>
#line 12 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpAlgorithm.cpp"

#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 112 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
#include <tulip/Graph.h>
#line 30 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpAlgorithm.cpp"
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 45 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpAlgorithm.cpp"
#line 30 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/PluginContext.sip"
#include <tulip/PluginContext.h>
#line 48 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpAlgorithm.cpp"
#line 29 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/../stl/string.sip"
	// Include the library interface to the type being mapped.
#include <string>
#line 52 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpAlgorithm.cpp"
#line 105 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/../stl/list.sip"
#include <list>
#line 55 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpAlgorithm.cpp"
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 68 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpAlgorithm.cpp"


class siptlp_Algorithm : public tlp::Algorithm
{
public:
    siptlp_Algorithm(tlp::AlgorithmContext);
    siptlp_Algorithm(const tlp::Algorithm&);
    virtual ~siptlp_Algorithm();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool run();
    bool check(std::string&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    siptlp_Algorithm(const siptlp_Algorithm &);
    siptlp_Algorithm &operator = (const siptlp_Algorithm &);

    char sipPyMethods[2];
};

siptlp_Algorithm::siptlp_Algorithm(tlp::AlgorithmContext a0): tlp::Algorithm(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

siptlp_Algorithm::siptlp_Algorithm(const tlp::Algorithm& a0): tlp::Algorithm(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

siptlp_Algorithm::~siptlp_Algorithm()
{
    sipCommonDtor(sipPySelf);
}

bool siptlp_Algorithm::run()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_Algorithm,sipName_run);

    if (!sipMeth)
        return 0;

    extern bool sipVH_tulip_17(sip_gilstate_t,PyObject *);

    return sipVH_tulip_17(sipGILState,sipMeth);
}

bool siptlp_Algorithm::check(std::string& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_check);

    if (!sipMeth)
        return tlp::Algorithm::check(a0);

    extern bool sipVH_tulip_78(sip_gilstate_t,PyObject *,std::string&);

    return sipVH_tulip_78(sipGILState,sipMeth,a0);
}


PyDoc_STRVAR(doc_tlp_Algorithm_run, "tlp.Algorithm.run()\n"
    "\n"
    "This method is the entry point of the algorithm when it is called.\n"
    "Derived classes must implement it. It is a good practice to report progress through the PluginProgress.\n"
    "The PluginProgress should also be used to report errors, if any. A boolean must also be returned\n"
    "to indicate if the algorithm was successful.\n"
    "\n"
    ":rtype: boolean	");

extern "C" {static PyObject *meth_tlp_Algorithm_run(PyObject *, PyObject *);}
static PyObject *meth_tlp_Algorithm_run(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::Algorithm *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Algorithm, &sipCpp))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_Algorithm, sipName_run);
                return NULL;
            }

            sipRes = sipCpp->run();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Algorithm, sipName_run, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_Algorithm_check, "tlp.Algorithm.check()\n"
    "\n"
    "This method is called before applying the algorithm on the input graph.\n"
    "You can perform some precondition checks here. Derived classes can reimplement it.\n"
    "Must return a tuple whose first member indicates if the algorithm can be applied\n"
    "and the second one can be used to provide an error message\n"
    "\n"
    ":rtype: (boolean, string)");

extern "C" {static PyObject *meth_tlp_Algorithm_check(PyObject *, PyObject *);}
static PyObject *meth_tlp_Algorithm_check(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        std::string * a0;
        tlp::Algorithm *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_Algorithm, &sipCpp))
        {
            bool sipRes;
            a0 = new std::string();

            sipRes = (sipSelfWasArg ? sipCpp->tlp::Algorithm::check(*a0) : sipCpp->check(*a0));

            return sipBuildResult(0,"(bN)",sipRes,a0,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Algorithm, sipName_check, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_tlp_Algorithm(void *, const sipTypeDef *);}
static void *cast_tlp_Algorithm(void *ptr, const sipTypeDef *targetType)
{
    void *res;

    if (targetType == sipType_tlp_Algorithm)
        return ptr;

    if ((res = ((const sipClassTypeDef *)sipType_tlp_WithParameter)->ctd_cast((tlp::WithParameter *)(tlp::Algorithm *)ptr,targetType)) != NULL)
        return res;

    if ((res = ((const sipClassTypeDef *)sipType_tlp_WithDependency)->ctd_cast((tlp::WithDependency *)(tlp::Algorithm *)ptr,targetType)) != NULL)
        return res;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_tlp_Algorithm(void *, int);}
static void release_tlp_Algorithm(void *sipCppV,int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<siptlp_Algorithm *>(sipCppV);
    else
        delete reinterpret_cast<tlp::Algorithm *>(sipCppV);
}


extern "C" {static void dealloc_tlp_Algorithm(sipSimpleWrapper *);}
static void dealloc_tlp_Algorithm(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<siptlp_Algorithm *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_tlp_Algorithm(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_tlp_Algorithm(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_tlp_Algorithm(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    siptlp_Algorithm *sipCpp = 0;

    {
        tlp::AlgorithmContext * a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_tlp_AlgorithmContext, &a0))
        {
            sipCpp = new siptlp_Algorithm(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const tlp::Algorithm * a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_tlp_Algorithm, &a0))
        {
            sipCpp = new siptlp_Algorithm(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_tlp_Algorithm[] = {{103, 255, 0}, {102, 255, 1}};


static PyMethodDef methods_tlp_Algorithm[] = {
    {SIP_MLNAME_CAST(sipName_check), meth_tlp_Algorithm_check, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Algorithm_check)},
    {SIP_MLNAME_CAST(sipName_run), meth_tlp_Algorithm_run, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_Algorithm_run)}
};


extern "C" {static PyObject *varget_tlp_Algorithm_dataSet(void *, PyObject *);}
static PyObject *varget_tlp_Algorithm_dataSet(void *sipSelf, PyObject *)
{
    tlp::DataSet *sipVal;
    tlp::Algorithm *sipCpp = reinterpret_cast<tlp::Algorithm *>(sipSelf);

    sipVal = sipCpp->dataSet;

    return sipConvertFromType(sipVal,sipType_tlp_DataSet, NULL);
}


extern "C" {static int varset_tlp_Algorithm_dataSet(void *, PyObject *, PyObject *);}
static int varset_tlp_Algorithm_dataSet(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::DataSet *sipVal;
    tlp::Algorithm *sipCpp = reinterpret_cast<tlp::Algorithm *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::DataSet *>(sipForceConvertToType(sipPy,sipType_tlp_DataSet,NULL,0,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->dataSet = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_tlp_Algorithm_graph(void *, PyObject *);}
static PyObject *varget_tlp_Algorithm_graph(void *sipSelf, PyObject *)
{
    tlp::Graph *sipVal;
    tlp::Algorithm *sipCpp = reinterpret_cast<tlp::Algorithm *>(sipSelf);

    sipVal = sipCpp->graph;

    return sipConvertFromType(sipVal,sipType_tlp_Graph, NULL);
}


extern "C" {static int varset_tlp_Algorithm_graph(void *, PyObject *, PyObject *);}
static int varset_tlp_Algorithm_graph(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::Graph *sipVal;
    tlp::Algorithm *sipCpp = reinterpret_cast<tlp::Algorithm *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::Graph *>(sipForceConvertToType(sipPy,sipType_tlp_Graph,NULL,0,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->graph = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_tlp_Algorithm_pluginProgress(void *, PyObject *);}
static PyObject *varget_tlp_Algorithm_pluginProgress(void *sipSelf, PyObject *)
{
    tlp::PluginProgress *sipVal;
    tlp::Algorithm *sipCpp = reinterpret_cast<tlp::Algorithm *>(sipSelf);

    sipVal = sipCpp->pluginProgress;

    return sipConvertFromType(sipVal,sipType_tlp_PluginProgress, NULL);
}


extern "C" {static int varset_tlp_Algorithm_pluginProgress(void *, PyObject *, PyObject *);}
static int varset_tlp_Algorithm_pluginProgress(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::PluginProgress *sipVal;
    tlp::Algorithm *sipCpp = reinterpret_cast<tlp::Algorithm *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::PluginProgress *>(sipForceConvertToType(sipPy,sipType_tlp_PluginProgress,NULL,0,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->pluginProgress = sipVal;

    return 0;
}

sipVariableDef variables_tlp_Algorithm[] = {
    {InstanceVariable, sipName_dataSet, (PyMethodDef *)varget_tlp_Algorithm_dataSet, (PyMethodDef *)varset_tlp_Algorithm_dataSet, NULL, NULL},
    {InstanceVariable, sipName_graph, (PyMethodDef *)varget_tlp_Algorithm_graph, (PyMethodDef *)varset_tlp_Algorithm_graph, NULL, NULL},
    {InstanceVariable, sipName_pluginProgress, (PyMethodDef *)varget_tlp_Algorithm_pluginProgress, (PyMethodDef *)varset_tlp_Algorithm_pluginProgress, NULL, NULL},
};

PyDoc_STRVAR(doc_tlp_Algorithm, "Bases: :class:`tlp.WithParameter`\n"
    "\n"
    "This abstract class describes a general algorithm plugin.\n"
    "Basic functionality consists in checking the algorithm can run on the current Graph \n"
    "(e.g. is the graph simple ?) then running the algorithm.\n"
    "The algorithm can and should report progress and which task it is performing \n"
    "if it is decomposed in multiple phases (e.g. layouting the graph, coloring it, ...).\n"
    "\n"
    ".. rubric:: class attributes\n"
    "\n"
    ".. py:attribute:: graph\n"
    "\n"
    "	The :class:`tlp.Graph` this algorithm will be run on.\n"
    "\n"
    ".. py:attribute:: dataSet\n"
    "\n"
    "	A :class:`tlp.DataSet` containing parameters for this algorithm, if any.\n"
    "	\n"
    ".. py:attribute:: pluginProgress\n"
    "\n"
    "	A :class:`tlp.PluginProgress` to give feedback to the user. It can be :const:`None`, so use with caution.	 \n"
    "\n"
    ".. rubric:: class methods\n"
    "");


sipClassTypeDef sipTypeDef_tulip_tlp_Algorithm = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_tlp__Algorithm,
        {0}
    },
    {
        sipNameNr_Algorithm,
        {21, 255, 0},
        2, methods_tlp_Algorithm,
        0, 0,
        3, variables_tlp_Algorithm,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_tlp_Algorithm,
    -1,
    -1,
    supers_tlp_Algorithm,
    0,
    init_tlp_Algorithm,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_tlp_Algorithm,
    0,
    0,
    0,
    release_tlp_Algorithm,
    cast_tlp_Algorithm,
    0,
    0,
    0
};

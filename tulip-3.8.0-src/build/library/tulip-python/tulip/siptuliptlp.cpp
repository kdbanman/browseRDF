/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Tue Apr 30 11:11:08 2013
 */

#include "sipAPItulip.h"

#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 24 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

#line 29 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/string.sip"
	// Include the library interface to the type being mapped.
#include <string>
#line 29 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 30 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Edge.sip"
#include <tulip/tulipconf.h>
#include <tulip/Edge.h>
#line 33 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 112 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
#include <tulip/Graph.h>
#line 50 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 29 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Node.sip"
#include <tulip/Node.h>
#line 53 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 32 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/BooleanProperty.sip"
#include <tulip/BooleanProperty.h>
#line 56 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 71 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 32 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DoubleProperty.sip"
#include <tulip/DoubleProperty.h>
#line 74 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 32 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/IntegerProperty.sip"
#include <tulip/IntegerProperty.h>
#line 77 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 29 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/set.sip"
#include <set>
#line 80 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 29 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginLoader.sip"
#include <tulip/PluginLoader.h>
#line 97 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 37 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 100 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 30 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/BoundingBox.sip"
#include <tulip/BoundingBox.h>
#line 103 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 32 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/LayoutProperty.sip"
#include <tulip/LayoutProperty.h>
#line 106 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 32 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/SizeProperty.sip"
#include <tulip/SizeProperty.h>
#line 109 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 29 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/pair.sip"
#include <utility>
#line 112 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 33 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Coord.sip"
#include <tulip/Coord.h>
#line 115 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 37 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 118 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 29 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/pair.sip"
#include <utility>
#line 121 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 37 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 124 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 37 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/vector.sip"
#include <vector>
#line 127 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 44 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Delaunay.sip"
#include <tulip/Delaunay.h>
#line 144 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"


PyDoc_STRVAR(doc_tlp_voronoiDiagram, "tlp.voronoiDiagram(sites)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes the voronoi diagram of a set of sites (for 2d and 3d layouts).\n"
    "It automatically computes the set of all voronoi\n"
    "vertices, edges and cells. In order to not have to deal with infinite\n"
    "voronoi rays, the input layout is enclosed in its convex hull in 2d or\n"
    "in its bounding box in 3d. It enables to have a connected voronoi cell\n"
    "for each input site.\n"
    "\n"
    ":param sites: the sites from which to compute the voronoi diagram\n"
    ":type sites: list of :class:`tlp.Coord`\n"
    ":rtype: :class:`tlp.VoronoiDiagram`");

extern "C" {static PyObject *meth_tlp_voronoiDiagram(PyObject *, PyObject *);}
static PyObject *meth_tlp_voronoiDiagram(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::vector<tlp::Coord> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100tlp_Coord,&a0, &a0State))
        {
            tlp::VoronoiDiagram *sipRes = 0;

#line 179 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Delaunay.sip"
    tlp::VoronoiDiagram voronoiDiagram;
    if (tlp::voronoiDiagram(*a0, voronoiDiagram)) {
        sipRes = new tlp::VoronoiDiagram(voronoiDiagram);
    } else {
        sipRes = NULL;
    }
#line 182 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(a0,sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_VoronoiDiagram,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_voronoiDiagram, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_delaunayTriangulation, "tlp.delaunayTriangulation(points)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes the delaunay triangulation of a set of points and returns the set of delaunay edges and simplices (triangles in 2d, tetrahedra in 3d).\n"
    "Returns a tuple whose first member is the list of edges and second member is the list of simplices, or :const:`None` if\n"
    "the triangulation failed.\n"
    "Edges and simplices are defined using indexes into the original list of points.\n"
    "\n"
    ":param points: a list of points on which to compute a delaunay triangulation\n"
    ":type points: list of :class:`tlp.Coord`\n"
    ":rtype: (list of (integer, integer), list of integer) or :const:`None`");

extern "C" {static PyObject *meth_tlp_delaunayTriangulation(PyObject *, PyObject *);}
static PyObject *meth_tlp_delaunayTriangulation(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::vector<tlp::Coord> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100tlp_Coord,&a0, &a0State))
        {
            std::pair<std_vector_0100std_pair_1900_1900,std_vector_0100std_vector_1900> *sipRes = 0;

#line 33 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Delaunay.sip"
    std::vector<std::pair<unsigned int, unsigned int> > edges;
    std::vector<std::vector<unsigned int> > simplices;
    if (tlp::delaunayTriangulation(*a0, edges, simplices)) {
        sipRes = new std::pair<std::vector<std::pair<unsigned int, unsigned int> >, std::vector<std::vector<unsigned int> > >(edges, simplices);
    } else {
        sipRes = NULL;
    }
#line 230 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(a0,sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_pair_0100std_vector_0100std_pair_1900_1900_0100std_vector_0100std_vector_1900,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_delaunayTriangulation, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computePolygonCentroid, "tlp.computePolygonCentroid(points)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes the centroid of a polygon.\n"
    "\n"
    ":param points: the vertices of the polygon correctly ordered\n"
    ":type points: list of :class:`tlp.Coord`\n"
    ":rtype: :class:`tlp.Coord`");

extern "C" {static PyObject *meth_tlp_computePolygonCentroid(PyObject *, PyObject *);}
static PyObject *meth_tlp_computePolygonCentroid(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<tlp::Coord> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100tlp_Coord,&a0, &a0State))
        {
            tlp::Coord *sipRes;

            sipRes = new tlp::Coord(tlp::computePolygonCentroid(*a0));
            sipReleaseType(const_cast<std::vector<tlp::Coord> *>(a0),sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(sipRes,sipType_tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computePolygonCentroid, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeLinesIntersection, "tlp.computeLinesIntersection(line1, line2)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes the intersection point (if any) of two 3d lines.\n"
    "Returns a tuple whose first member is a boolean indicating\n"
    "if the lines intersect (if :const:`False` it means that lines are parallel or skew)\n"
    "and second member is the intersection point (if any).\n"
    "\n"
    ":param line1: the coordinates of the two points defining the first line\n"
    ":type line1: (:class:`tlp.Coord` , :class:`tlp.Coord`)\n"
    ":param line2: the coordinates of the two points defining the second line\n"
    ":type line2: (:class:`tlp.Coord` , :class:`tlp.Coord`)\n"
    ":rtype: (boolean, :class:`tlp.Coord`)");

extern "C" {static PyObject *meth_tlp_computeLinesIntersection(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeLinesIntersection(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::pair<tlp::Coord,tlp::Coord> * a0;
        int a0State = 0;
        const std::pair<tlp::Coord,tlp::Coord> * a1;
        int a1State = 0;
        tlp::Coord * a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1", sipType_std_pair_0100tlp_Coord_0100tlp_Coord,&a0, &a0State, sipType_std_pair_0100tlp_Coord_0100tlp_Coord,&a1, &a1State))
        {
            bool sipRes;
            a2 = new tlp::Coord();

            sipRes = tlp::computeLinesIntersection(*a0,*a1,*a2);
            sipReleaseType(const_cast<std::pair<tlp::Coord,tlp::Coord> *>(a0),sipType_std_pair_0100tlp_Coord_0100tlp_Coord,a0State);
            sipReleaseType(const_cast<std::pair<tlp::Coord,tlp::Coord> *>(a1),sipType_std_pair_0100tlp_Coord_0100tlp_Coord,a1State);

            return sipBuildResult(0,"(bN)",sipRes,a2,sipType_tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeLinesIntersection, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeConvexHull, "tlp.computeConvexHull(points)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a convex hull of a set of points. Only works with 2D layouts.\n"
    "Returns a list of :class:`tlp.Coord` containing the vertices of the points convex hull correctly ordered.\n"
    "\n"
    ":param points: the points on which to compute a conbex hull\n"
    ":type points: :list of class:`tlp.Coord`\n"
    ":rtype: list of :class:`tlp.Coord`\n"
    "tlp.computeConvexHull(graph[, selection = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a convex hull of a graph according to nodes positions and edges bends\n"
    "defined in the default layout property \"viewLayout\", nodes z-rotations defined in the default double property \"viewRotation\"\n"
    "and sizes of elements defined in the default size property \"viewSize\". Only works with 2D layouts.\n"
    "Returns a list of :class:`tlp.Coord` containing the vertices of the graph convex hull correctly ordered.\n"
    "\n"
    ":param graph: the graph on which to compute its convex hull\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param selection: a boolean property to restrain the computation of the convex hull to selected elements (if provided)\n"
    ":type selection: :class:`tlp.BooleanProperty`\n"
    ":rtype: list of :class:`tlp.Coord`\n"
    ":throws: an exception if the provided boolean property is not attached to the graph\n"
    "tlp.computeConvexHull(graph, layout, size, rotation[, selection = None])\n"
    "\n"
    "Computes a convex hull of a graph according to nodes positions, edges bends,\n"
    "nodes z-rotations, and sizes of elements. Only works with 2D layouts.\n"
    "Returns a list of :class:`tlp.Coord` containing the vertices of the graph convex hull correctly ordered.\n"
    "\n"
    ":param graph: the graph on which to compute its convex hull\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param layout: a layout property containing positions of the graph elements\n"
    ":type layout: :class:`tlp.LayoutProperty`\n"
    ":param size: a size property containing the sizes of the graph elements.\n"
    ":type size: :class:`tlp.SizeProperty`\n"
    ":param rotation: a double property containing the z-rotations of nodes\n"
    ":type rotation: :class:`tlp.DoubleProperty`\n"
    ":param selection: a boolean property to restrain the computation of the convex hull to selected elements (if provided)\n"
    ":type selection: :class:`tlp.BooleanProperty`\n"
    ":rtype: list of :class:`tlp.Coord`\n"
    ":throws: an exception if the provided properties are not attached to the graph");

extern "C" {static PyObject *meth_tlp_computeConvexHull(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeConvexHull(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<tlp::Coord> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100tlp_Coord,&a0, &a0State))
        {
            std::vector<tlp::Coord> *sipRes;

            sipRes = new std::vector<tlp::Coord>(tlp::computeConvexHull(*a0));
            sipReleaseType(const_cast<std::vector<tlp::Coord> *>(a0),sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100tlp_Coord,NULL);
        }
    }

    {
        tlp::Graph * a0;
        tlp::BooleanProperty * a1 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_BooleanProperty, &a1))
        {
            std::vector<tlp::Coord> *sipRes = 0;
            int sipIsErr = 0;

#line 208 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DrawingTools.sip"
    if (!(a0 == a1->getGraph() || a1->getGraph()->isDescendantGraph(a0))) {
        sipIsErr = 1;
        PyErr_SetString(PyExc_Exception, "The provided boolean property is not attached to the graph on which to compute its convex hull.");
    } else {
        sipRes = new std::vector<tlp::Coord>(tlp::computeConvexHull(a0, a0->getProperty<tlp::LayoutProperty>("viewLayout"),
                                                                    a0->getProperty<tlp::SizeProperty>("viewSize"),
                                                                    a0->getProperty<tlp::DoubleProperty>("viewRotation"),
                                                                    a1));
    }
#line 411 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100tlp_Coord,NULL);
        }
    }

    {
        tlp::Graph * a0;
        tlp::LayoutProperty * a1;
        tlp::SizeProperty * a2;
        tlp::DoubleProperty * a3;
        tlp::BooleanProperty * a4 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J8J8J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_LayoutProperty, &a1, sipType_tlp_SizeProperty, &a2, sipType_tlp_DoubleProperty, &a3, sipType_tlp_BooleanProperty, &a4))
        {
            std::vector<tlp::Coord> *sipRes = 0;
            int sipIsErr = 0;

#line 248 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DrawingTools.sip"
	if (!(a0 == a1->getGraph() || a1->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided layout property is not attached to the graph on which to compute its convex hull.");
	} else if (!(a0 == a2->getGraph() || a2->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided size property is not attached to the graph on which to compute its convex hull.");
	} else if (!(a0 == a3->getGraph() || a3->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided double property is not attached to the graph on which to compute its convex hull.");
	} else if (a4 && !(a0 == a4->getGraph() || a4->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided boolean property is not attached to the graph on which to compute its convex hull.");
	} else {
		sipRes = new std::vector<tlp::Coord>(tlp::computeConvexHull(a0, a1, a2, a3, a4));
	}
#line 448 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeConvexHull, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeBoundingRadius, "tlp.computeBoundingRadius(graph[, selection = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes a bounding sphere (or a bounding circle if the graph has a 2D layout) of a graph according to nodes positions and edges bends\n"
    "defined in the default layout property \"viewLayout\", nodes z-rotations defined in the default double property \"viewRotation\"\n"
    "and sizes of elements defined in the default size property \"viewSize\".\n"
    "\n"
    "Returns a tuple of :class:`tlp.Coord` whose first member is the center of the bounding sphere (circle for 2D layout)\n"
    "and second member is the farthest point from the center (computed from graph elements positions).\n"
    "To get the bounding radius, you have to compute the distance between the two members of the tuple\n"
    "(use the :meth:`tlp.Vec3f.dist` method).\n"
    "\n"
    ":param graph: the graph on which to compute its bounding sphere\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param selection: a boolean property to restrain the computation of the bounding sphere to selected elements (if provided)\n"
    ":type selection: :class:`tlp.BooleanProperty`\n"
    ":rtype: (:class:`tlp.Coord`, :class:`tlp.Coord`)\n"
    ":throws: an exception if the provided boolean property is not attached to the graph\n"
    "\n"
    "tlp.computeBoundingRadius(graph, layout, size, rotation[, selection = None])\n"
    "\n"
    "Computes a bounding sphere (or a bounding circle if the graph has a 2D layout) of a graph according to node position edge bends\n"
    "node z-rotation, and size of elements.\n"
    "\n"
    "Returns a tuple of :class:`tlp.Coord` whose first member is the center of the bounding sphere (circle for 2D layout)\n"
    "and second member is the farthest point from the center (computed from graph elements positions).\n"
    "To get the bounding radius, you have to compute the distance between the two members of the tuple \n"
    "(use the :meth:`tlp.Vec3f.dist` method). \n"
    "\n"
    ":param graph: the graph on which to compute its bounding sphere\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param layout: a layout property containing positions of the graph elements\n"
    ":type layout: :class:`tlp.LayoutProperty`\n"
    ":param size: a size property containing the sizes of the graph elements.\n"
    ":type size: :class:`tlp.SizeProperty`\n"
    ":param rotation: a double property containing the z-rotations of nodes\n"
    ":type rotation: :class:`tlp.DoubleProperty`\n"
    ":param selection: a boolean property to restrain the computation of the bounding sphere to selected elements (if provided)\n"
    ":type selection: :class:`tlp.BooleanProperty`\n"
    ":rtype: (:class:`tlp.Coord`, :class:`tlp.Coord`)\n"
    ":throws: an exception if the provided properties are not attached to the graph\n"
    "");

extern "C" {static PyObject *meth_tlp_computeBoundingRadius(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeBoundingRadius(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::BooleanProperty * a1 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_BooleanProperty, &a1))
        {
            std::pair<tlp::Coord,tlp::Coord> *sipRes = 0;
            int sipIsErr = 0;

#line 108 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DrawingTools.sip"
    if (!(a0 == a1->getGraph() || a1->getGraph()->isDescendantGraph(a0))) {
        sipIsErr = 1;
        PyErr_SetString(PyExc_Exception, "The provided boolean property is not attached to the graph on which to compute its bounding sphere.");
    } else {
        sipRes = new std::pair<tlp::Coord, tlp::Coord>(tlp::computeBoundingRadius(a0, a0->getProperty<tlp::LayoutProperty>("viewLayout"),
                                                                                  a0->getProperty<tlp::SizeProperty>("viewSize"),
                                                                                  a0->getProperty<tlp::DoubleProperty>("viewRotation"),
                                                                                  a1));
    }
#line 532 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_pair_0100tlp_Coord_0100tlp_Coord,NULL);
        }
    }

    {
        tlp::Graph * a0;
        tlp::LayoutProperty * a1;
        tlp::SizeProperty * a2;
        tlp::DoubleProperty * a3;
        tlp::BooleanProperty * a4 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J8J8J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_LayoutProperty, &a1, sipType_tlp_SizeProperty, &a2, sipType_tlp_DoubleProperty, &a3, sipType_tlp_BooleanProperty, &a4))
        {
            std::pair<tlp::Coord,tlp::Coord> *sipRes = 0;
            int sipIsErr = 0;

#line 153 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DrawingTools.sip"
	if (!(a0 == a1->getGraph() || a1->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided layout property is not attached to the graph on which to compute its bounding sphere.");
	} else if (!(a0 == a2->getGraph() || a2->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided size property is not attached to the graph on which to compute its bounding sphere.");
	} else if (!(a0 == a3->getGraph() || a3->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided double property is not attached to the graph on which to compute its bounding sphere.");
	} else if (a4 && !(a0 == a4->getGraph() || a4->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided boolean property is not attached to the graph on which to compute its bounding sphere.");
	} else {
		sipRes = new std::pair<tlp::Coord, tlp::Coord>(tlp::computeBoundingRadius(a0, a1, a2, a3, a4));
	}
#line 569 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_pair_0100tlp_Coord_0100tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeBoundingRadius, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeBoundingBox, "tlp.computeBoundingBox(graph[, selection = None])\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Computes the bounding box of a graph according to nodes positions and edges bends defined in the default layout property \"viewLayout\",\n"
    "nodes z-rotations defined in the default double property \"viewRotation\" and sizes of elements defined in the default size property \"viewSize\".\n"
    "\n"
    ":param graph: the graph on which to compute its bounding box\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param selection: a boolean property to restrain the computation of the bounding box to selected elements (if provided)\n"
    ":type selection: :class:`tlp.BooleanProperty`\n"
    ":rtype: :class:`tlp.BoundingBox`\n"
    ":throws: an exception if the provided boolean property is not attached to the graph\n"
    "tlp.computeBoundingBox(graph, layout, size, rotation[, selection = None])\n"
    "\n"
    "Computes the bounding box of a graph according to nodes positions, edges bends,\n"
    "nodes z-rotations and sizes of elements.\n"
    "\n"
    ":param graph: the graph on which to compute its bounding box\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param layout: a layout property containing positions of the graph elements\n"
    ":type layout: :class:`tlp.LayoutProperty`\n"
    ":param size: a size property containing the sizes of the graph elements.\n"
    ":type size: :class:`tlp.SizeProperty`\n"
    ":param rotation: a double property containing the z-rotations of nodes\n"
    ":type rotation: :class:`tlp.DoubleProperty`\n"
    ":param selection: a boolean property to restrain the computation of the bounding box to selected elements (if provided)\n"
    ":type selection: :class:`tlp.BooleanProperty`\n"
    ":rtype: :class:`tlp.BoundingBox`\n"
    ":throws: an exception if the provided properties are not attached to the graph");

extern "C" {static PyObject *meth_tlp_computeBoundingBox(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeBoundingBox(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::BooleanProperty * a1 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_BooleanProperty, &a1))
        {
            tlp::BoundingBox *sipRes = 0;
            int sipIsErr = 0;

#line 25 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DrawingTools.sip"
    if (a1 && !(a0 == a1->getGraph() || a1->getGraph()->isDescendantGraph(a0))) {
        sipIsErr = 1;
        PyErr_SetString(PyExc_Exception, "The provided boolean property is not attached to the graph on which to compute its bounding box.");
    } else {
        sipRes = new tlp::BoundingBox(tlp::computeBoundingBox(a0, a0->getProperty<tlp::LayoutProperty>("viewLayout"),
                                                              a0->getProperty<tlp::SizeProperty>("viewSize"),
                                                              a0->getProperty<tlp::DoubleProperty>("viewRotation"),
                                                              a1));
    }
#line 640 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_BoundingBox,NULL);
        }
    }

    {
        tlp::Graph * a0;
        tlp::LayoutProperty * a1;
        tlp::SizeProperty * a2;
        tlp::DoubleProperty * a3;
        tlp::BooleanProperty * a4 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J8J8J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_LayoutProperty, &a1, sipType_tlp_SizeProperty, &a2, sipType_tlp_DoubleProperty, &a3, sipType_tlp_BooleanProperty, &a4))
        {
            tlp::BoundingBox *sipRes = 0;
            int sipIsErr = 0;

#line 64 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/DrawingTools.sip"
	if (!(a0 == a1->getGraph() || a1->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided layout property is not attached to the graph on which to compute its bounding box.");
	} else if (!(a0 == a2->getGraph() || a2->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided size property is not attached to the graph on which to compute its bounding box.");
	} else if (!(a0 == a3->getGraph() || a3->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided double property is not attached to the graph on which to compute its bounding box.");
	} else if (a4 && !(a0 == a4->getGraph() || a4->getGraph()->isDescendantGraph(a0))) {
		sipIsErr = 1;
		PyErr_SetString(PyExc_Exception, "The provided boolean property is not attached to the graph on which to compute its bounding box.");
	} else {
		sipRes = new tlp::BoundingBox(tlp::computeBoundingBox(a0, a1, a2, a3, a4));
	}
#line 677 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_BoundingBox,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeBoundingBox, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getStringAlgorithmPluginsList, "tlp.getStringAlgorithmPluginsList()\n"
    "\n"
    "Return a list containing the names of the string algorithm plugins (written in C++ or Python) loaded so far.\n"
    "String algorithm plugins are objects implementing the tlp::StringAlgorithm interface in C++ or \n"
    "the :class:`tlp.StringAlgorithm` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getStringAlgorithmPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getStringAlgorithmPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 376 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getAlgorithmPluginsListOfType("String"));
#line 713 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getStringAlgorithmPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getSizeAlgorithmPluginsList, "tlp.getSizeAlgorithmPluginsList()\n"
    "\n"
    "Return a list containing the names of the size algorithm plugins (written in C++ or Python) loaded so far.\n"
    "Size algorithm plugins are objects implementing the tlp::SizeAlgorithm interface in C++ or \n"
    "the :class:`tlp.SizeAlgorithm` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getSizeAlgorithmPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getSizeAlgorithmPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 359 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getAlgorithmPluginsListOfType("Size"));
#line 746 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getSizeAlgorithmPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getLayoutAlgorithmPluginsList, "tlp.getLayoutAlgorithmPluginsList()\n"
    "\n"
    "Return a list containing the names of the layout algorithm plugins (written in C++ or Python) loaded so far.\n"
    "Layout algorithm plugins are objects implementing the tlp::LayoutAlgorithm interface in C++ or \n"
    "the :class:`tlp.LayoutAlgorithm` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getLayoutAlgorithmPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getLayoutAlgorithmPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 342 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getAlgorithmPluginsListOfType("Color"));
#line 779 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getLayoutAlgorithmPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getColorAlgorithmPluginsList, "tlp.getColorAlgorithmPluginsList()\n"
    "\n"
    "Return a list containing the names of the color algorithm plugins (written in C++ or Python) loaded so far.\n"
    "Color algorithm plugins are objects implementing the tlp::ColorAlgorithm interface in C++ or \n"
    "the :class:`tlp.ColorAlgorithm` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getColorAlgorithmPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getColorAlgorithmPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 325 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getAlgorithmPluginsListOfType("Color"));
#line 812 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getColorAlgorithmPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getDoubleAlgorithmPluginsList, "tlp.getDoubleAlgorithmPluginsList()\n"
    "\n"
    "Return a list containing the names of the double algorithm plugins (written in C++ or Python) loaded so far.\n"
    "Double algorithm plugins are objects implementing the tlp::DoubleAlgorithm interface in C++ or \n"
    "the :class:`tlp.DoubleAlgorithm` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getDoubleAlgorithmPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getDoubleAlgorithmPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 308 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getAlgorithmPluginsListOfType("Double"));
#line 845 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getDoubleAlgorithmPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getIntegerAlgorithmPluginsList, "tlp.getIntegerAlgorithmPluginsList()\n"
    "\n"
    "Return a list containing the names of the integer algorithm plugins (written in C++ or Python) loaded so far.\n"
    "Integer algorithm plugins are objects implementing the tlp::IntegerAlgorithm interface in C++ or \n"
    "the :class:`tlp.IntegerAlgorithm` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getIntegerAlgorithmPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getIntegerAlgorithmPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 291 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getAlgorithmPluginsListOfType("Integer"));
#line 878 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getIntegerAlgorithmPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getBooleanAlgorithmPluginsList, "tlp.getBooleanAlgorithmPluginsList()\n"
    "\n"
    "Return a list containing the names of the boolean algorithm plugins (written in C++ or Python) loaded so far.\n"
    "Boolean algorithm plugins are objects implementing the tlp::BooleanAlgorithm interface in C++ or \n"
    "the :class:`tlp.BooleanAlgorithm` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getBooleanAlgorithmPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getBooleanAlgorithmPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 274 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getAlgorithmPluginsListOfType("Boolean"));
#line 911 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getBooleanAlgorithmPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getExportPluginsList, "tlp.getExportPluginsList()\n"
    "\n"
    "Return a list containing the names of the export plugins (written in C++ or Python) loaded so far.\n"
    "Export plugins are objects implementing the tlp::ExportModule interface \n"
    "in C++ or the :class:`tlp.ExportModule` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getExportPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getExportPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 257 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getPluginsList<tlp::ExportModule>());
#line 944 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getExportPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getImportPluginsList, "tlp.getImportPluginsList()\n"
    "\n"
    "Return a list containing the names of the import plugins (written in C++ or Python) loaded so far.\n"
    "Import plugins are objects implementing the tlp::ImportModule interface \n"
    "in C++ or the :class:`tlp.ImportModule` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getImportPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getImportPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 240 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getPluginsList<tlp::ImportModule>());
#line 977 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getImportPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getAlgorithmPluginsList, "tlp.getAlgorithmPluginsList()\n"
    "\n"
    "Return a list containing the names of the algorithm plugins (written in C++ or Python) loaded so far.\n"
    "Algorithm plugins are objects implementing the tlp::Algorithm interface \n"
    "in C++ or the :class:`tlp.Algorithm` interface in Python.\n"
    "\n"
    ":rtype: list of string");

extern "C" {static PyObject *meth_tlp_getAlgorithmPluginsList(PyObject *, PyObject *);}
static PyObject *meth_tlp_getAlgorithmPluginsList(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::vector<std::string> *sipRes = 0;

#line 223 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::vector<std::string>(getAlgorithmPluginsListOfType("Algorithm"));
#line 1010 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getAlgorithmPluginsList, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getDefaultPluginParameters, "tlp.getDefaultPluginParameters(pluginName[, graph = None])\n"
    "\n"
    "Returns a dataset filled with default parameters (if any) for a given plugin (algorithm, import, property algorithm, ...).\n"
    "\n"
    ":param pluginName: the name of the plugin on which to retrieve its default parameters\n"
    ":type pluginName: string\n"
    ":param graph: if provided, property parameters will be retrieved from the graph if they exist\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":rtype: :class:`tlp.DataSet`");

extern "C" {static PyObject *meth_tlp_getDefaultPluginParameters(PyObject *, PyObject *);}
static PyObject *meth_tlp_getDefaultPluginParameters(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::Graph * a1 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|J8", sipType_std_string,&a0, &a0State, sipType_tlp_Graph, &a1))
        {
            tlp::DataSet *sipRes = 0;
            int sipIsErr = 0;

#line 187 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	tlp::TemplateFactoryInterface *selectedFactory = NULL;
	tlp::DataSet result;
	std::map< std::string, tlp::TemplateFactoryInterface* >::iterator it = tlp::TemplateFactoryInterface::allFactories->begin();
	for (; it != tlp::TemplateFactoryInterface::allFactories->end() ; ++it) {
		if (it->second->pluginExists(*a0)) {
			selectedFactory = it->second;
			break;
		}
	} 
	if (selectedFactory) {
		const tlp::ParameterDescriptionList&  parameters = selectedFactory->getPluginParameters(*a0);
		parameters.buildDefaultDataSet(result, a1);
		sipRes = new tlp::DataSet(result);
	} else {
		sipIsErr = 1;
		std::string msg = "No plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 1069 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_tlp_DataSet,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getDefaultPluginParameters, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_loadPluginsCheckDependencies, "tlp.loadPluginsCheckDependencies()\n"
    "\n"
    "Checks the dependencies of all C++ plugins loaded so far. \n"
    "If a plugin does not have all its dependencies fulfilled,\n"
    "it is unloaded and removed from the current plugins database.");

extern "C" {static PyObject *meth_tlp_loadPluginsCheckDependencies(PyObject *, PyObject *);}
static PyObject *meth_tlp_loadPluginsCheckDependencies(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::PluginLoader * a0 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "|J8", sipType_tlp_PluginLoader, &a0))
        {
#line 163 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
    if (!a0) {
        tlp::PluginLoaderTxt pluginLoaderTxt;
        tlp::loadPluginsCheckDependencies(&pluginLoaderTxt);
    } else {
        tlp::loadPluginsCheckDependencies(a0);
    }
#line 1109 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_loadPluginsCheckDependencies, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_loadPluginsFromDir, "tlp.loadPluginsFromDir(dir)\n"
    "\n"
    "Loads C++ plugins located in a specific directory.\n"
    "\n"
    ":param dir: the path to the directory containing the Tulip plugins\n"
    ":type dir: string");

extern "C" {static PyObject *meth_tlp_loadPluginsFromDir(PyObject *, PyObject *);}
static PyObject *meth_tlp_loadPluginsFromDir(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::string * a0;
        int a0State = 0;
        std::string a1def = "Algorithm";
        std::string * a1 = &a1def;
        int a1State = 0;
        tlp::PluginLoader * a2 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|J1J8", sipType_std_string,&a0, &a0State, sipType_std_string,&a1, &a1State, sipType_tlp_PluginLoader, &a2))
        {
#line 143 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
    if (!a2) {
        tlp::PluginLoaderTxt pluginLoaderTxt;
        tlp::loadPluginsFromDir(*a0, *a1, &pluginLoaderTxt);
    } else {
        tlp::loadPluginsFromDir(*a0, *a1, a2);
    }
#line 1152 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(a0,sipType_std_string,a0State);
            sipReleaseType(a1,sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_loadPluginsFromDir, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_loadPlugin, "tlp.loadPlugin(filename)\n"
    "\n"
    "Loads a C++ plugin from a specific shared library.\n"
    "Returns :const:`True` if the plugin was correctly loaded.\n"
    "\n"
    ":param filename: the path to the shared library containing the Tulip plugin (file extension : .so on linux, .dylib on mac, .dll on windows)\n"
    ":type filename: string\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_loadPlugin(PyObject *, PyObject *);}
static PyObject *meth_tlp_loadPlugin(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::PluginLoader * a1 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|J8", sipType_std_string,&a0, &a0State, sipType_tlp_PluginLoader, &a1))
        {
            bool sipRes = 0;

#line 122 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
      if (!a1) {
        tlp::PluginLoaderTxt pluginLoaderTxt;
        tlp::loadPlugin(*a0, &pluginLoaderTxt);
      } else {
        tlp::loadPlugin(*a0, a1);
      }
#line 1198 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_loadPlugin, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_loadPlugins, "tlp.loadPlugins()\n"
    "\n"
    "Loads C++ plugins installed in the directories listed in the tlp.TulipPluginsPath variable\n"
    "(in the form \"<path1>;<path2>\" on windows and \"<path1>:<path2>\" on unix).\n"
    "The tlp.TulipPluginsPath can be initialized with standard Tulip directories \n"
    "by calling the :func:`tlp.initTulipLib` function.");

extern "C" {static PyObject *meth_tlp_loadPlugins(PyObject *, PyObject *);}
static PyObject *meth_tlp_loadPlugins(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::PluginLoader * a0 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "|J8", sipType_tlp_PluginLoader, &a0))
        {
#line 99 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
    if (!a0) {
        tlp::PluginLoaderTxt pluginLoaderTxt;
        tlp::loadPlugins(&pluginLoaderTxt);
    } else {
        tlp::loadPlugins(a0);
    }
#line 1236 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_loadPlugins, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_initTulipLib, "tlp.initTulipLib([appDirPath=None])\n"
    "\n"
    "Looks for the Tulip plugins directory and fills the Tulip path variables : tlp.TulipLibDir, tlp.TulipPluginsPath, tlp.TulipBitmapDir.\n"
    "The plug-ins directory can be defined in different ways, given by order of prevalence:\n"
    "\n"
    "   * the TLP_DIR environment variable, if it has a value\n"
    "\n"
    "   * from the optional appDirPath parameter that must point to the path where the tulip binary is located\n"
    "\n"
    "   * a fallback value of 'C:/Tulip/lib/' on windows, or '/usr/local/lib/' on unix\n"
    "\n"
    ":param appDirPath: if provided, the Tulip plugins directory will be defined according to the provided Tulip binary path.\n"
    "                   This parameter should only be used when using the tulip module provided in a precompiled Tulip bundle (typically on MacOS and Windows)\n"
    "                   through the classical Python interpreter. In that case, the Tulip application directory has been hardcoded in the binaries\n"
    "                   when they were compiled and so does not match your local Tulip installation. If you do not provide the correct Tulip binary\n"
    "                   path, you won't be able to load and call plugins.\n"
    ":type appDirPath: string");

extern "C" {static PyObject *meth_tlp_initTulipLib(PyObject *, PyObject *);}
static PyObject *meth_tlp_initTulipLib(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string& a0def = "";
        const std::string * a0 = &a0def;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "|J1", sipType_std_string,&a0, &a0State))
        {
#line 79 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
    const char *appDirPathStr = NULL;
    if ((*a0) != "") {
        appDirPathStr = (*a0).c_str();
    }
    tlp::initTulipLib(appDirPathStr);
#line 1286 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_initTulipLib, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getTulipRelease, "tlp.getTulipRelease()\n"
    "\n"
    "Returns the current version number of Tulip in the form X.Y.Z,\n"
    "X being the major version, Y the minor version, and Z the patch version.\n"
    "\n"
    ":rtype: string");

extern "C" {static PyObject *meth_tlp_getTulipRelease(PyObject *, PyObject *);}
static PyObject *meth_tlp_getTulipRelease(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            std::string *sipRes = 0;

#line 52 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/TlpTools.sip"
	sipRes = new std::string(TULIP_RELEASE);
#line 1320 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getTulipRelease, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_reachableNodes, "tlp.reachableNodes(graph, startNode, maxDistance, direction)\n"
    "\n"
    "Returns the nodes that can be reached from a node, according to a direction,\n"
    "at distance less or equal to a maximum one.\n"
    "\n"
    ":param graph: the graph to work on\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param startNode: an existing graph node\n"
    ":type startNode: :class:`tlp.node`\n"
    ":param maxDistance: the maximum distance to reach nodes\n"
    ":type maxDistance: integer\n"
    ":param direction: specify if the graph must be directed or not\n"
    ":type direction: tlp.DIRECTED, tlp.INV_DIRECTED, tlp.UNDIRECTED  \n"
    ":rtype: list of :class:`tlp.node`\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_reachableNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_reachableNodes(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph * a0;
        const tlp::node * a1;
        std::set<tlp::node> * a2;
        uint a3;
        tlp::EDGE_TYPE a4 = tlp::UNDIRECTED;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J9u|E", sipType_tlp_Graph, &a0, sipType_tlp_node, &a1, &a3, sipType_tlp_EDGE_TYPE, &a4))
        {
            a2 = new std::set<tlp::node>();
            int sipIsErr = 0;

#line 164 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/GraphMeasure.sip"
	if (a0->isElement(*a1)) {
		tlp::reachableNodes(a0, *a1, *a2, a3);
	} else {
		sipIsErr = throwInvalidNodeException(a0, *a1);
	}
#line 1372 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(a2,sipType_std_set_0100tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_reachableNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_maxDistance, "tlp.maxDistance(graph, node, result, direction)\n"
    "  \n"
    "Computes the distances from a node to all the other nodes of a graph and return the maximum one.\n"
    "\n"
    ":param graph: the graph on which to compute the maximum distance\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param node: an existing graph node\n"
    ":type node: :class:`tlp.node`\n"
    ":param result: a graph property in which the results will be stored\n"
    ":type result: :class:`tlp.IntegerProperty`\n"
    ":param direction: specify if the graph must be directed or not\n"
    ":type direction: tlp.DIRECTED, tlp.INV_DIRECTED, tlp.UNDIRECTED\n"
    ":rtype: integer\n"
    ":throws: an exception if the node does not belong to the graph");

extern "C" {static PyObject *meth_tlp_maxDistance(PyObject *, PyObject *);}
static PyObject *meth_tlp_maxDistance(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph * a0;
        const tlp::node * a1;
        tlp::IntegerProperty * a2;
        tlp::EDGE_TYPE a3 = tlp::UNDIRECTED;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J9J8|E", sipType_tlp_Graph, &a0, sipType_tlp_node, &a1, sipType_tlp_IntegerProperty, &a2, sipType_tlp_EDGE_TYPE, &a3))
        {
            uint sipRes = 0;
            int sipIsErr = 0;

#line 132 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/GraphMeasure.sip"
	if (a0->isElement(*a1)) {
		tlp::MutableContainer<unsigned int> result;
		tlp::maxDistance(a0, *a1, result, a3);
		tlp::node n;
		forEach(n, a0->getNodes()) {
			a2->setNodeValue(n, static_cast<int>(result.get(n)));
		}
	} else {
		sipIsErr = throwInvalidNodeException(a0, *a1);
	}
#line 1430 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            if (sipIsErr)
                return 0;

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_maxDistance, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_minDegree, "tlp.minDegree(graph)\n"
    "\n"
    "Returns the minimum degree of the graph's nodes.\n"
    "\n"
    ":param graph: the graph on which to compute the minimum degree\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":rtype: integer");

extern "C" {static PyObject *meth_tlp_minDegree(PyObject *, PyObject *);}
static PyObject *meth_tlp_minDegree(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8", sipType_tlp_Graph, &a0))
        {
            uint sipRes;

            sipRes = tlp::minDegree(a0);

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_minDegree, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_maxDegree, "tlp.maxDegree(graph)\n"
    "\n"
    "Returns the maximum degree of the graph's nodes.\n"
    "\n"
    ":param graph: the graph on which to compute the maximum degree\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":rtype: integer");

extern "C" {static PyObject *meth_tlp_maxDegree(PyObject *, PyObject *);}
static PyObject *meth_tlp_maxDegree(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8", sipType_tlp_Graph, &a0))
        {
            uint sipRes;

            sipRes = tlp::maxDegree(a0);

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_maxDegree, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_dagLevel, "tlp.dagLevel(graph, result)\n"
    "\n"
    "Assigns to each node of a Directed Acyclic Graph a level such that\n"
    "if the edge e(u,v) exists level(u) < level(v). \n"
    "The algorithm ensures that the number of level used is minimal.\n"
    "\n"
    ":param graph: the graph on which to compute the dag level\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param result: a graph property in which the results will be stored\n"
    ":type result: :class:`tlp.IntegerProperty`\n"
    "\n"
    ".. warning:: The graph must be acyclic (no self loops).\n"
    "");

extern "C" {static PyObject *meth_tlp_dagLevel(PyObject *, PyObject *);}
static PyObject *meth_tlp_dagLevel(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph * a0;
        tlp::IntegerProperty * a1;
        tlp::PluginProgress * a2 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_IntegerProperty, &a1, sipType_tlp_PluginProgress, &a2))
        {
#line 83 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/GraphMeasure.sip"
	tlp::MutableContainer<unsigned int> result;
	tlp::dagLevel(a0, result, a2);
	tlp::node n;
	forEach(n, a0->getNodes()) {
		a1->setNodeValue(n, static_cast<int>(result.get(n)));
	}
#line 1545 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_dagLevel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_clusteringCoefficient, "tlp.clusteringCoefficient(graph, result[, maxDepth = 1])\n"
    "\n"
    "Assigns to each node its local clustering coefficient\n"
    "that is the proportion of edges between the nodes within its neighbourhood\n"
    "divided by the number of edges that could possibly exist between them.\n"
    "This quantifies how close its neighbors are to being a clique.\n"
    "\n"
    ":param graph: the graph on which to compute the clustering coefficient for each node\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param result: a graph property in which the results will be stored\n"
    ":type result: :class:`tlp.DoubleProperty`\n"
    ":param maxDepth: the maximum distance between each node and its neighbours.\n"
    ":type maxDepth: integer  	");

extern "C" {static PyObject *meth_tlp_clusteringCoefficient(PyObject *, PyObject *);}
static PyObject *meth_tlp_clusteringCoefficient(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph * a0;
        tlp::DoubleProperty * a1;
        uint a2 = 1;
        tlp::PluginProgress * a3 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J8|uJ8", sipType_tlp_Graph, &a0, sipType_tlp_DoubleProperty, &a1, &a2, sipType_tlp_PluginProgress, &a3))
        {
#line 55 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/GraphMeasure.sip"
	tlp::MutableContainer<double> result;
	tlp::clusteringCoefficient(a0, result, a2, a3);
	tlp::node n;
	forEach(n, a0->getNodes()) {
		a1->setNodeValue(n, result.get(n));
	}
#line 1593 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_clusteringCoefficient, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_averageClusteringCoefficient, "tlp.averageClusteringCoefficient(graph)\n"
    "  	\n"
    "Returns the clustering coefficient of a graph\n"
    "as the average of the local clustering coefficients\n"
    "(see :func:`tlp.clusteringCoefficient`) of all the nodes.\n"
    "\n"
    ":param graph: the graph on wich to compute the average clustering coefficient\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":rtype: float");

extern "C" {static PyObject *meth_tlp_averageClusteringCoefficient(PyObject *, PyObject *);}
static PyObject *meth_tlp_averageClusteringCoefficient(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph * a0;
        tlp::PluginProgress * a1 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_PluginProgress, &a1))
        {
            double sipRes;

            sipRes = tlp::averageClusteringCoefficient(a0,a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_averageClusteringCoefficient, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_averagePathLength, "tlp.averagePathLength(graph)\n"
    "\n"
    "Returns the average path length of a graph, that is the sum\n"
    "of the shortest distances for all pair of distinct nodes in that graph\n"
    "divided by the number of those pairs. For a pair of non connected nodes,\n"
    "the shorted distance is set to 0.\n"
    "\n"
    ":param graph: the graph on which to compute the average path length\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":rtype: float");

extern "C" {static PyObject *meth_tlp_averagePathLength(PyObject *, PyObject *);}
static PyObject *meth_tlp_averagePathLength(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Graph * a0;
        tlp::PluginProgress * a1 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_PluginProgress, &a1))
        {
            double sipRes;

            sipRes = tlp::averagePathLength(a0,a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_averagePathLength, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_removeFromGraph, "tlp.removeFromGraph(inGraph[, inSelection = None])\n"
    "\n"
    "Removes the selected part of a graph (properties values, nodes and edges).\n"
    "If no selection is done, the whole graph is reseted to default value.\n"
    "\n"
    ":param inGraph: the graph on which to remove elements\n"
    ":type inGraph: :class:`tlp.Graph`\n"
    ":param inSelection: boolean property attached to inGraph, only selected elements will be removed if provided\n"
    ":type inSelection: :class:`tlp.BooleanProperty`\n"
    "\n"
    ".. warning:: The selection is extended to all selected edge ends.\n"
    "");

extern "C" {static PyObject *meth_tlp_removeFromGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_removeFromGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::BooleanProperty * a1 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8|J8", sipType_tlp_Graph, &a0, sipType_tlp_BooleanProperty, &a1))
        {
            tlp::removeFromGraph(a0,a1);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_removeFromGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_copyToGraph, "tlp.copyToGraph(outGraph, inGraph[, inSelection = None, outSelection = None])\n"
    "\n"
    "Appends the selected part of a graph (properties, nodes and edges) into another one.\n"
    "If no selection is done, the whole input graph graph is appended.\n"
    "The output selection is used to select the appended nodes & edges\n"
    "\n"
    ":param outGraph: the graph on which to append elements\n"
    ":type outGraph: :class:`tlp.Graph`\n"
    ":param inGraph: the graph to append\n"
    ":type inGraph: :class:`tlp.Graph`\n"
    ":param inSelection: boolean property attached to inGraph, only selected elements will be appended if provided\n"
    ":type inSelection: :class:`tlp.BooleanProperty`\n"
    ":param outSelection: boolean property attached to outGraph, appended nodes and edges will be selected if provided \n"
    ":type outSelection: :class:`tlp.BooleanProperty`\n"
    "\n"
    ".. warning:: The input selection is extended to all selected edge ends.\n"
    "");

extern "C" {static PyObject *meth_tlp_copyToGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_copyToGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::Graph * a1;
        tlp::BooleanProperty * a2 = 0;
        tlp::BooleanProperty * a3 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J8|J8J8", sipType_tlp_Graph, &a0, sipType_tlp_Graph, &a1, sipType_tlp_BooleanProperty, &a2, sipType_tlp_BooleanProperty, &a3))
        {
            tlp::copyToGraph(a0,a1,a2,a3);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_copyToGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_getSource, "tlp.getSource(graph)\n"
    "\n"
    ".. deprecated:: 3.7 use :meth:`tlp.Graph.getSource` instead\n"
    "\n"
    "Finds the first node whose input degree equals 0.\n"
    "Returns a tuple whose first member is a boolean indicating if such node exists and\n"
    "second member is the found node (invalid if there is no source);\n"
    "\n"
    ":param graph: the graph on which to find a source\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":rtype: (boolean, :class:`tlp.node`)");

extern "C" {static PyObject *meth_tlp_getSource(PyObject *, PyObject *);}
static PyObject *meth_tlp_getSource(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::node * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8", sipType_tlp_Graph, &a0))
        {
            bool sipRes;
            a1 = new tlp::node();

            sipRes = tlp::getSource(a0,*a1);

            return sipBuildResult(0,"(bN)",sipRes,a1,sipType_tlp_node,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_getSource, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_newCloneSubGraph, "tlp.newCloneSubGraph(root[, name = \"unnamed\"])\n"
    "\n"
    ".. deprecated:: 3.7 use :meth:`tlp.Graph.addCloneSubGraph` instead\n"
    "\n"
    "Creates and returns a subgraph of a graph root that is equal to that graph (a clone subgraph).\n"
    "\n"
    ":param root: the graph on which the subgraph will be created\n"
    ":type root: :class:`tlp.Graph`\n"
    ":param name: the subgraph name\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_newCloneSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_newCloneSubGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        std::string a1def = "unnamed";
        std::string * a1 = &a1def;
        int a1State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8|J1", sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            tlp::Graph *sipRes;

            sipRes = tlp::newCloneSubGraph(a0,*a1);
            sipReleaseType(a1,sipType_std_string,a1State);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_newCloneSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_newSubGraph, "tlp.newSubGraph(root[, name = \"unnamed\"])\n"
    "\n"
    ".. deprecated:: 3.7 use :meth:`tlp.Graph.addSubGraph` instead\n"
    "\n"
    "Creates and returns an empty subgraph of a graph.\n"
    "\n"
    ":param root: the graph on which the subgraph will be created\n"
    ":type root: :class:`tlp.Graph`\n"
    ":param name: the subgraph name\n"
    ":type name: string\n"
    ":rtype: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_newSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_newSubGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        std::string a1def = "unnamed";
        std::string * a1 = &a1def;
        int a1State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8|J1", sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            tlp::Graph *sipRes;

            sipRes = tlp::newSubGraph(a0,*a1);
            sipReleaseType(a1,sipType_std_string,a1State);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_newSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_applyAlgorithm, "tlp.applyAlgorithm(graph, dataSet, algoName)\n"
    "\n"
    ".. deprecated:: 3.7 use :meth:`tlp.Graph.applyAlgorithm` instead\n"
    "\n"
    "Applies an algorithm plugin (must be loaded) on a graph . Algorithm plugins are objects\n"
    "implementing the tlp::Algorithm interface in C++ or the :class:`tlp.Algorithm` interface in Python. \n"
    "The list of currently loaded algorithm plugins can be\n"
    "retrieved through the :func:`tlp.getAlgorithmPluginsList` function.\n"
    "Parameters can be transmit to the algorithm trough a DataSet object (refer to the plugin \n"
    "documentation to get its parameters list). \n"
    "\n"
    "Returns a tuple whose first member is a boolean indicating if the algorithm has been successfully applied\n"
    "and second member is a string that can contain an error message if the algorithms fails during\n"
    "its execution.\n"
    "\n"
    ":param graph: the graph on which to apply the algorithm\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param dataSet: a dataset filled with parameters to transmit to the algorithm\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":param algoName: the name of the algorithm plugin to call\n"
    ":type algoName: string\n"
    ":rtype: (boolean, string)\n"
    ":throws: an exception if the requested algorithm plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call algorithms (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_applyAlgorithm(PyObject *, PyObject *);}
static PyObject *meth_tlp_applyAlgorithm(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        std::string * a1;
        tlp::DataSet * a2;
        const std::string * a3;
        int a3State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J8J1", sipType_tlp_Graph, &a0, sipType_tlp_DataSet, &a2, sipType_std_string,&a3, &a3State))
        {
            bool sipRes = 0;
            a1 = new std::string();
            int sipIsErr = 0;

#line 3871 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a3, "Algorithm")) {
		sipRes = tlp::applyAlgorithm(a0, *a1, a2, *a3);
	} else {
		sipIsErr = 1;
        std::string msg = "No Tulip general algorithm plugin named  ";
		msg += *a3;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 1939 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(const_cast<std::string *>(a3),sipType_std_string,a3State);

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(bN)",sipRes,a1,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_applyAlgorithm, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_exportGraph, "tlp.exportGraph(graph, outputFilePath, exportPluginName[, dataSet])\n"
    "\n"
    "Exports a graph to a file using a Tulip export plugin (must be loaded).\n"
    "Export plugins are objects implementing the tlp::ExportModule interface\n"
    "in C++ or the :class:`tlp.ExportModule` interface in Python.\n"
    "The list of currently loaded export plugins can be\n"
    "retrieved through the :func:`tlp.getExportPluginsList` function.\n"
    "\n"
    ":param graph: the graph to export\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param outputFilePath: the path of the file the export plugin will write to\n"
    ":type outputFilePath: string\n"
    ":param exportPluginName: the name of the Tulip export plugin to execute\n"
    ":type exportPluginName: string\n"
    ":param dataSet: a dataset filled with parameters to transmit to the export plugin\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":rtype: boolean\n"
    ":throws: an exception if the requested export plugin is not registered in the plugins database. \n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call export modules (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_exportGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_exportGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        const std::string * a2;
        int a2State = 0;
        tlp::DataSet a3def = tlp::DataSet();
        tlp::DataSet * a3 = &a3def;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J1J1|J9", sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State, sipType_std_string,&a2, &a2State, sipType_tlp_DataSet, &a3))
        {
            bool sipRes = 0;
            int sipIsErr = 0;

#line 3816 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a2, "Export")) {
		std::ofstream ofs((*a1).c_str());
		if (ofs.is_open()) {
			sipRes = tlp::exportGraph(a0, ofs, *a2, *a3);
		} else {
			std::string msg = "Export error : The specified file path (";
			msg += *a1;
			msg += ") is not valid.";  
			printErrorMessage(msg);
			sipRes = false;
		}
		
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip export plugin named  ";
		msg += *a1;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 2017 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);
            sipReleaseType(const_cast<std::string *>(a2),sipType_std_string,a2State);

            if (sipIsErr)
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_exportGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_importGraph, "tlp.importGraph(importPluginName[, dataSet, newGraph = None])\n"
    "\n"
    "Imports a graph using a Tulip import plugin (must be loaded).\n"
    "Import plugins are objects implementing the tlp::ImportModule interface\n"
    "in C++ or the :class:`tlp.ImportModule` interface in Python.\n"
    "The list of currently loaded import plugins can be\n"
    "retrieved through the :func:`tlp.getImportPluginsList` function.\n"
    "Returns a new graph or None if the import fails.\n"
    "\n"
    ":param importPluginName: the name of the Tulip import plugin\n"
    ":type importPluginName: string\n"
    ":param dataSet: a dataset filled with parameters to transmit to the import plugin\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":param newGraph: if provided, add imported graph elements in that graph\n"
    ":type newGraph: :class:`tlp.Graph`\n"
    ":rtype: :class:`tlp.Graph`\n"
    ":throws: an exception if the requested import plugin is not registered in the plugins database. \n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call import modules (see :ref:`Loading Tulip plugins <loading-plugins>`)).\n"
    "tlp.importGraph(importPluginName, dataSet[, newGraph = None])\n"
    "\n"
    "Imports a graph using a Tulip import plugin (must be loaded).\n"
    "Import plugins are objects implementing the tlp::ImportModule interface\n"
    "in C++ or the :class:`tlp.ImportModule` interface in Python.\n"
    "The list of currently loaded import plugins can be\n"
    "retrieved through the :func:`tlp.getImportPluginsList` function.\n"
    "Returns a new graph or None if the import fails.\n"
    "\n"
    ":param importPluginName: the name of the Tulip import plugin\n"
    ":type importPluginName: string\n"
    ":param dataSet: a dataset filled with parameters to transmit to the import plugin\n"
    ":type dataSet: :class:`tlp.DataSet`\n"
    ":param newGraph: if provided, add imported graph elements in that graph\n"
    ":type newGraph: :class:`tlp.Graph`\n"
    ":rtype: :class:`tlp.Graph`\n"
    ":throws: an exception if the requested import plugin is not registered in the plugins database.\n"
    "\n"
    ".. warning:: If you are using the bindings through the classical Python interpreter, Tulip plugins must be loaded in order to be\n"
    "             able to call import modules (see :ref:`Loading Tulip plugins <loading-plugins>`)).");

extern "C" {static PyObject *meth_tlp_importGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_importGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::DataSet a1def = tlp::DataSet();
        tlp::DataSet * a1 = &a1def;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|J9", sipType_std_string,&a0, &a0State, sipType_tlp_DataSet, &a1))
        {
            tlp::Graph *sipRes = 0;
            int sipIsErr = 0;

#line 3738 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Import")) {
        sipRes = tlp::importGraph(*a0, *a1, 0);
        initializeGraphViewProperties(sipRes);
	} else {
		sipIsErr = 1;
		std::string msg = "No Tulip import plugin named  ";
		msg += *a0;
		msg += ".";
		PyErr_SetString(PyExc_Exception, msg.c_str());
	}	
#line 2103 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_Graph,Py_None);
        }
    }

    {
        const std::string * a0;
        int a0State = 0;
        tlp::DataSet * a1;
        tlp::Graph * a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J9J8", sipType_std_string,&a0, &a0State, sipType_tlp_DataSet, &a1, sipType_tlp_Graph, &a2))
        {
            tlp::Graph *sipRes = 0;
            int sipIsErr = 0;

#line 3775 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    if (pluginExists(*a0, "Import")) {
        sipRes = tlp::importGraph(*a0, *a1, 0, a2);
        initializeGraphViewProperties(sipRes);
    } else {
        sipIsErr = 1;
        std::string msg = "No Tulip import plugin named  ";
        msg += *a0;
        msg += ".";
        PyErr_SetString(PyExc_Exception, msg.c_str());
    }
#line 2135 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_importGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_saveGraph, "tlp.saveGraph(graph, filename)\n"
    "\n"
    "Saves a graph to a file in the tlp format. Extension of the destination file can be either \n"
    ".tlp (raw export) or .tlp.gz (compressed export). Returns :const:`True` if the graph has been \n"
    "successfully saved.\n"
    "\n"
    ":param graph: the graph to export\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param filename: the path to the destination file\n"
    ":type filename: string\n"
    ":rtype: boolean\n"
    "");

extern "C" {static PyObject *meth_tlp_saveGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_saveGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J1", sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            bool sipRes;

            sipRes = tlp::saveGraph(a0,*a1);
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_saveGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_loadGraph, "tlp.loadGraph(filename)\n"
    "\n"
    "Loads a graph in the tlp format from a file (extension can be .tlp or .tlp.gz).\n"
    "Returns a new graph or :const:`None` if the import fails.\n"
    "\n"
    ":param filename: the path to the tlp file\n"
    ":type filename: string\n"
    ":rtype: :class:`tlp.Graph`\n"
    "");

extern "C" {static PyObject *meth_tlp_loadGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_loadGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_string,&a0, &a0State))
        {
            tlp::Graph *sipRes = 0;

#line 3689 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    sipRes = tlp::loadGraph(*a0);
    initializeGraphViewProperties(sipRes);
#line 2219 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipConvertFromType(sipRes,sipType_tlp_Graph,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_loadGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_newGraph, "tlp.newGraph()\n"
    "\n"
    "Creates and returns a new empty graph.\n"
    "\n"
    ":rtype: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_newGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_newGraph(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            tlp::Graph *sipRes = 0;

#line 3669 "/home/kdbanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
    sipRes = tlp::newGraph();
    initializeGraphViewProperties(sipRes);
#line 2252 "/home/kdbanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlp.cpp"

            return sipConvertFromType(sipRes,sipType_tlp_Graph,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_newGraph, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_tlp_nextFaceEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_nextFaceEdge(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::Graph * a0;
        tlp::edge * a1;
        tlp::node * a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8J9J9", sipType_tlp_Graph, &a0, sipType_tlp_edge, &a1, sipType_tlp_node, &a2))
        {
            tlp::edge *sipRes;

            sipRes = new tlp::edge(tlp::nextFaceEdge(a0,*a1,*a2));

            return sipConvertFromNewType(sipRes,sipType_tlp_edge,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_nextFaceEdge, NULL);

    return NULL;
}


static PyMethodDef methods_tlp[] = {
    {SIP_MLNAME_CAST(sipName_applyAlgorithm), meth_tlp_applyAlgorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_applyAlgorithm)},
    {SIP_MLNAME_CAST(sipName_averageClusteringCoefficient), meth_tlp_averageClusteringCoefficient, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_averageClusteringCoefficient)},
    {SIP_MLNAME_CAST(sipName_averagePathLength), meth_tlp_averagePathLength, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_averagePathLength)},
    {SIP_MLNAME_CAST(sipName_clusteringCoefficient), meth_tlp_clusteringCoefficient, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_clusteringCoefficient)},
    {SIP_MLNAME_CAST(sipName_computeBoundingBox), meth_tlp_computeBoundingBox, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeBoundingBox)},
    {SIP_MLNAME_CAST(sipName_computeBoundingRadius), meth_tlp_computeBoundingRadius, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeBoundingRadius)},
    {SIP_MLNAME_CAST(sipName_computeConvexHull), meth_tlp_computeConvexHull, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeConvexHull)},
    {SIP_MLNAME_CAST(sipName_computeLinesIntersection), meth_tlp_computeLinesIntersection, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeLinesIntersection)},
    {SIP_MLNAME_CAST(sipName_computePolygonCentroid), meth_tlp_computePolygonCentroid, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computePolygonCentroid)},
    {SIP_MLNAME_CAST(sipName_copyToGraph), meth_tlp_copyToGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_copyToGraph)},
    {SIP_MLNAME_CAST(sipName_dagLevel), meth_tlp_dagLevel, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_dagLevel)},
    {SIP_MLNAME_CAST(sipName_delaunayTriangulation), meth_tlp_delaunayTriangulation, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_delaunayTriangulation)},
    {SIP_MLNAME_CAST(sipName_exportGraph), meth_tlp_exportGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_exportGraph)},
    {SIP_MLNAME_CAST(sipName_getAlgorithmPluginsList), meth_tlp_getAlgorithmPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getAlgorithmPluginsList)},
    {SIP_MLNAME_CAST(sipName_getBooleanAlgorithmPluginsList), meth_tlp_getBooleanAlgorithmPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getBooleanAlgorithmPluginsList)},
    {SIP_MLNAME_CAST(sipName_getColorAlgorithmPluginsList), meth_tlp_getColorAlgorithmPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getColorAlgorithmPluginsList)},
    {SIP_MLNAME_CAST(sipName_getDefaultPluginParameters), meth_tlp_getDefaultPluginParameters, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getDefaultPluginParameters)},
    {SIP_MLNAME_CAST(sipName_getDoubleAlgorithmPluginsList), meth_tlp_getDoubleAlgorithmPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getDoubleAlgorithmPluginsList)},
    {SIP_MLNAME_CAST(sipName_getExportPluginsList), meth_tlp_getExportPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getExportPluginsList)},
    {SIP_MLNAME_CAST(sipName_getImportPluginsList), meth_tlp_getImportPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getImportPluginsList)},
    {SIP_MLNAME_CAST(sipName_getIntegerAlgorithmPluginsList), meth_tlp_getIntegerAlgorithmPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getIntegerAlgorithmPluginsList)},
    {SIP_MLNAME_CAST(sipName_getLayoutAlgorithmPluginsList), meth_tlp_getLayoutAlgorithmPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getLayoutAlgorithmPluginsList)},
    {SIP_MLNAME_CAST(sipName_getSizeAlgorithmPluginsList), meth_tlp_getSizeAlgorithmPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getSizeAlgorithmPluginsList)},
    {SIP_MLNAME_CAST(sipName_getSource), meth_tlp_getSource, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getSource)},
    {SIP_MLNAME_CAST(sipName_getStringAlgorithmPluginsList), meth_tlp_getStringAlgorithmPluginsList, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getStringAlgorithmPluginsList)},
    {SIP_MLNAME_CAST(sipName_getTulipRelease), meth_tlp_getTulipRelease, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_getTulipRelease)},
    {SIP_MLNAME_CAST(sipName_importGraph), meth_tlp_importGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_importGraph)},
    {SIP_MLNAME_CAST(sipName_initTulipLib), meth_tlp_initTulipLib, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_initTulipLib)},
    {SIP_MLNAME_CAST(sipName_loadGraph), meth_tlp_loadGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_loadGraph)},
    {SIP_MLNAME_CAST(sipName_loadPlugin), meth_tlp_loadPlugin, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_loadPlugin)},
    {SIP_MLNAME_CAST(sipName_loadPlugins), meth_tlp_loadPlugins, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_loadPlugins)},
    {SIP_MLNAME_CAST(sipName_loadPluginsCheckDependencies), meth_tlp_loadPluginsCheckDependencies, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_loadPluginsCheckDependencies)},
    {SIP_MLNAME_CAST(sipName_loadPluginsFromDir), meth_tlp_loadPluginsFromDir, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_loadPluginsFromDir)},
    {SIP_MLNAME_CAST(sipName_maxDegree), meth_tlp_maxDegree, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_maxDegree)},
    {SIP_MLNAME_CAST(sipName_maxDistance), meth_tlp_maxDistance, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_maxDistance)},
    {SIP_MLNAME_CAST(sipName_minDegree), meth_tlp_minDegree, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_minDegree)},
    {SIP_MLNAME_CAST(sipName_newCloneSubGraph), meth_tlp_newCloneSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_newCloneSubGraph)},
    {SIP_MLNAME_CAST(sipName_newGraph), meth_tlp_newGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_newGraph)},
    {SIP_MLNAME_CAST(sipName_newSubGraph), meth_tlp_newSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_newSubGraph)},
    {SIP_MLNAME_CAST(sipName_nextFaceEdge), meth_tlp_nextFaceEdge, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_reachableNodes), meth_tlp_reachableNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_reachableNodes)},
    {SIP_MLNAME_CAST(sipName_removeFromGraph), meth_tlp_removeFromGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_removeFromGraph)},
    {SIP_MLNAME_CAST(sipName_saveGraph), meth_tlp_saveGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_saveGraph)},
    {SIP_MLNAME_CAST(sipName_voronoiDiagram), meth_tlp_voronoiDiagram, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_voronoiDiagram)}
};

static sipEnumMemberDef enummembers_tlp[] = {
    {sipName_DIRECTED, tlp::DIRECTED, 44},
    {sipName_EDGE, tlp::EDGE, 50},
    {sipName_INV_DIRECTED, tlp::INV_DIRECTED, 44},
    {sipName_NODE, tlp::NODE, 50},
    {sipName_TLP_CANCEL, tlp::TLP_CANCEL, 84},
    {sipName_TLP_CONTINUE, tlp::TLP_CONTINUE, 84},
    {sipName_TLP_STOP, tlp::TLP_STOP, 84},
    {sipName_UNDIRECTED, tlp::UNDIRECTED, 44},
};


extern "C" {static PyObject *varget_tlp_TulipBitmapDir(void *, PyObject *);}
static PyObject *varget_tlp_TulipBitmapDir(void *, PyObject *)
{
    std::string *sipVal;
    sipVal = &tlp::TulipBitmapDir;

    return sipConvertFromType(sipVal,sipType_std_string, NULL);
}


extern "C" {static int varset_tlp_TulipBitmapDir(void *, PyObject *, PyObject *);}
static int varset_tlp_TulipBitmapDir(void *, PyObject *sipPy, PyObject *)
{
    std::string *sipVal;
    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast<std::string *>(sipForceConvertToType(sipPy,sipType_std_string,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    tlp::TulipBitmapDir = *sipVal;

    sipReleaseType(sipVal, sipType_std_string, sipValState);

    return 0;
}


extern "C" {static PyObject *varget_tlp_TulipDocProfile(void *, PyObject *);}
static PyObject *varget_tlp_TulipDocProfile(void *, PyObject *)
{
    std::string *sipVal;
    sipVal = &tlp::TulipDocProfile;

    return sipConvertFromType(sipVal,sipType_std_string, NULL);
}


extern "C" {static int varset_tlp_TulipDocProfile(void *, PyObject *, PyObject *);}
static int varset_tlp_TulipDocProfile(void *, PyObject *sipPy, PyObject *)
{
    std::string *sipVal;
    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast<std::string *>(sipForceConvertToType(sipPy,sipType_std_string,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    tlp::TulipDocProfile = *sipVal;

    sipReleaseType(sipVal, sipType_std_string, sipValState);

    return 0;
}


extern "C" {static PyObject *varget_tlp_TulipLibDir(void *, PyObject *);}
static PyObject *varget_tlp_TulipLibDir(void *, PyObject *)
{
    std::string *sipVal;
    sipVal = &tlp::TulipLibDir;

    return sipConvertFromType(sipVal,sipType_std_string, NULL);
}


extern "C" {static int varset_tlp_TulipLibDir(void *, PyObject *, PyObject *);}
static int varset_tlp_TulipLibDir(void *, PyObject *sipPy, PyObject *)
{
    std::string *sipVal;
    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast<std::string *>(sipForceConvertToType(sipPy,sipType_std_string,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    tlp::TulipLibDir = *sipVal;

    sipReleaseType(sipVal, sipType_std_string, sipValState);

    return 0;
}


extern "C" {static PyObject *varget_tlp_TulipPluginsPath(void *, PyObject *);}
static PyObject *varget_tlp_TulipPluginsPath(void *, PyObject *)
{
    std::string *sipVal;
    sipVal = &tlp::TulipPluginsPath;

    return sipConvertFromType(sipVal,sipType_std_string, NULL);
}


extern "C" {static int varset_tlp_TulipPluginsPath(void *, PyObject *, PyObject *);}
static int varset_tlp_TulipPluginsPath(void *, PyObject *sipPy, PyObject *)
{
    std::string *sipVal;
    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast<std::string *>(sipForceConvertToType(sipPy,sipType_std_string,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    tlp::TulipPluginsPath = *sipVal;

    sipReleaseType(sipVal, sipType_std_string, sipValState);

    return 0;
}


extern "C" {static PyObject *varget_tlp_TulipUserHandBookIndex(void *, PyObject *);}
static PyObject *varget_tlp_TulipUserHandBookIndex(void *, PyObject *)
{
    std::string *sipVal;
    sipVal = &tlp::TulipUserHandBookIndex;

    return sipConvertFromType(sipVal,sipType_std_string, NULL);
}


extern "C" {static int varset_tlp_TulipUserHandBookIndex(void *, PyObject *, PyObject *);}
static int varset_tlp_TulipUserHandBookIndex(void *, PyObject *sipPy, PyObject *)
{
    std::string *sipVal;
    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast<std::string *>(sipForceConvertToType(sipPy,sipType_std_string,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    tlp::TulipUserHandBookIndex = *sipVal;

    sipReleaseType(sipVal, sipType_std_string, sipValState);

    return 0;
}

sipVariableDef variables_tlp[] = {
    {ClassVariable, sipName_TulipBitmapDir, (PyMethodDef *)varget_tlp_TulipBitmapDir, (PyMethodDef *)varset_tlp_TulipBitmapDir, NULL, NULL},
    {ClassVariable, sipName_TulipDocProfile, (PyMethodDef *)varget_tlp_TulipDocProfile, (PyMethodDef *)varset_tlp_TulipDocProfile, NULL, NULL},
    {ClassVariable, sipName_TulipLibDir, (PyMethodDef *)varget_tlp_TulipLibDir, (PyMethodDef *)varset_tlp_TulipLibDir, NULL, NULL},
    {ClassVariable, sipName_TulipPluginsPath, (PyMethodDef *)varget_tlp_TulipPluginsPath, (PyMethodDef *)varset_tlp_TulipPluginsPath, NULL, NULL},
    {ClassVariable, sipName_TulipUserHandBookIndex, (PyMethodDef *)varget_tlp_TulipUserHandBookIndex, (PyMethodDef *)varset_tlp_TulipUserHandBookIndex, NULL, NULL},
};


sipClassTypeDef sipTypeDef_tulip_tlp = {
    {
        -1,
        0,
        0,
        SIP_TYPE_NAMESPACE,
        sipNameNr_tlp,
        {0}
    },
    {
        sipNameNr_tlp,
        {0, 0, 1},
        44, methods_tlp,
        8, enummembers_tlp,
        5, variables_tlp,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    0,
    -1,
    -1,
    0,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

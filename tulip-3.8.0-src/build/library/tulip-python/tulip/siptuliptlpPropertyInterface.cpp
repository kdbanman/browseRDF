/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Mon Apr 29 01:46:11 2013
 */

#include "sipAPItulip.h"

#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
#include <tulip/PropertyInterface.h>
#line 12 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"

#line 29 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Node.sip"
#include <tulip/Node.h>
#line 16 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
#line 29 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/../stl/string.sip"
	// Include the library interface to the type being mapped.
#include <string>
#line 20 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Edge.sip"
#include <tulip/tulipconf.h>
#include <tulip/Edge.h>
#line 24 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
#line 24 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/ObservableProperty.sip"
#include <tulip/ObservableProperty.h>
#line 27 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Iterator.sip"
#include <tulip/Iterator.h>
#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 112 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
#include <tulip/Graph.h>
#line 47 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Iterator.sip"
#include <tulip/Iterator.h>
#line 50 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"


PyDoc_STRVAR(doc_tlp_PropertyInterface_getGraph, "tlp.PropertyInterface.getGraph()\n"
    "\n"
    "Returns the graph on which the property has been defined.\n"
    "\n"
    ":rtype: :class:`tlp.Graph`\n"
    "\n"
    ".. warning:: If the property is inherited the graph could be different\n"
    "             that the one used to get that property.\n"
    "");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp))
        {
            tlp::Graph *sipRes;

            sipRes = sipCpp->getGraph();

            return sipConvertFromType(sipRes,sipType_tlp_Graph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_getNonDefaultValuatedNodes, "tlp.PropertyInterface.getNonDefaultValuatedNodes([subgraph = None])\n"
    "\n"
    "Returns an iterator on all nodes whose value is different\n"
    "from the default value. \n"
    "\n"
    ":param subgraph: a sub-graph can be given in parameter. In that case, only the nodes owned by this sub-graph are returned by the iterator.\n"
    ":type subgraph: :class:`tlp.Graph`\n"
    ":rtype: :class:`tlp.IteratorNode`");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getNonDefaultValuatedNodes(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getNonDefaultValuatedNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::Graph * a0 = 0;
        const tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B|J8", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_Graph, &a0))
        {
            tlp::IteratorNode *sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_getNonDefaultValuatedNodes);
                return NULL;
            }

            sipRes = sipCpp->getNonDefaultValuatedNodes(a0);

            return sipConvertFromType(sipRes,sipType_tlp_IteratorNode,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getNonDefaultValuatedNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_getNonDefaultValuatedEdges, "tlp.PropertyInterface.getNonDefaultValuatedEdges([subgraph = None])\n"
    "\n"
    "Returns an iterator on all edges whose value is different\n"
    "from the default value. \n"
    "\n"
    ":param subgraph: a sub-graph can be given in parameter. In that case, only the edges owned by this sub-graph are returned by the iterator.\n"
    ":type subgraph: :class:`tlp.Graph`\n"
    ":rtype: :class:`tlp.IteratorEdge`");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getNonDefaultValuatedEdges(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getNonDefaultValuatedEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::Graph * a0 = 0;
        const tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B|J8", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_Graph, &a0))
        {
            tlp::IteratorEdge *sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_getNonDefaultValuatedEdges);
                return NULL;
            }

            sipRes = sipCpp->getNonDefaultValuatedEdges(a0);

            return sipConvertFromType(sipRes,sipType_tlp_IteratorEdge,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getNonDefaultValuatedEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_getTypename, "tlp.PropertyInterface.getTypename()\n"
    "\n"
    "Returns a string describing the type of the property,\n"
    "i.e. \"graph\", \"double\", \"layout\", \"string\", \"integer\", \"color\", \"size\", ...\n"
    "\n"
    ":rtype: string");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getTypename(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getTypename(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp))
        {
            std::string *sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_getTypename);
                return NULL;
            }

            sipRes = new std::string(sipCpp->getTypename());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getTypename, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_getName, "tlp.PropertyInterface.getName()\n"
    "\n"
    "Returns the name of the property.\n"
    "\n"
    ":rtype: string");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getName(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp))
        {
            std::string *sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_getName);
                return NULL;
            }

            sipRes = new std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getName, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_getNodeDefaultStringValue, "tlp.PropertyInterface.getNodeDefaultStringValue()\n"
    "\n"
    "Returns a string representation of the node default value.\n"
    "\n"
    ":rtype: string");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getNodeDefaultStringValue(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getNodeDefaultStringValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp))
        {
            std::string *sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_getNodeDefaultStringValue);
                return NULL;
            }

            sipRes = new std::string(sipCpp->getNodeDefaultStringValue());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getNodeDefaultStringValue, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_getEdgeDefaultStringValue, "tlp.PropertyInterface.getEdgeDefaultStringValue()\n"
    "\n"
    "Returns a string representation of the edge default value.\n"
    "\n"
    ":rtype: string");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getEdgeDefaultStringValue(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getEdgeDefaultStringValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp))
        {
            std::string *sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_getEdgeDefaultStringValue);
                return NULL;
            }

            sipRes = new std::string(sipCpp->getEdgeDefaultStringValue());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getEdgeDefaultStringValue, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_setAllNodeStringValue, "tlp.PropertyInterface.setAllNodeStringValue(str)\n"
    "\n"
    "Clears all nodes registered values, and sets a new node default value\n"
    "in converting the given string representation of a value.\n"
    "Returns :const:`True` if the given string representation has been successfully converted to a value, :const:`False` otherwise.\n"
    "\n"
    ":param str: a string representation of a value\n"
    ":type str: string\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_PropertyInterface_setAllNodeStringValue(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_setAllNodeStringValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_setAllNodeStringValue);
                return NULL;
            }

            sipRes = sipCpp->setAllNodeStringValue(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_setAllNodeStringValue, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_setAllEdgeStringValue, "tlp.PropertyInterface.setAllEdgeStringValue(str)\n"
    "\n"
    "Clears all edges registered values, and sets a new edge default value\n"
    "in converting the given string representation of a value.\n"
    "Returns :const:`True` if the given string representation has been successfully converted to a value, :const:`False` otherwise.\n"
    "\n"
    ":param str: a string representation of a value\n"
    ":type str: string\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_PropertyInterface_setAllEdgeStringValue(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_setAllEdgeStringValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const std::string * a0;
        int a0State = 0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_setAllEdgeStringValue);
                return NULL;
            }

            sipRes = sipCpp->setAllEdgeStringValue(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_setAllEdgeStringValue, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_erase, "tlp.PropertyInterface.erase(node)\n"
    "\n"
    "Removes the value stored for the node given in parameter.\n"
    "The new value for the node is the default one.\n"
    "\n"
    ":param node: an existing node\n"
    ":type node: :class:`tlp.node`\n"
    ":throws: an exception if the node does not belong to the graph attached to the property\n"
    "tlp.PropertyInterface.erase(edge)\n"
    "\n"
    "Removes the value stored for the edge given in parameter.\n"
    "The new value for the edge is the default one.\n"
    "\n"
    ":param edge: an existing edge\n"
    ":type edge: :class:`tlp.edge`\n"
    ":throws: an exception if the edge does not belong to the graph attached to the property");

extern "C" {static PyObject *meth_tlp_PropertyInterface_erase(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_erase(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::node * a0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_node, &a0))
        {
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_erase);
                return NULL;
            }

#line 201 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipCpp->erase(*a0);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp->getGraph(), *a0);
	}
#line 458 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const tlp::edge * a0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_edge, &a0))
        {
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_erase);
                return NULL;
            }

#line 223 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipCpp->erase(*a0);
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp->getGraph(), *a0);
	}
#line 488 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_erase, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_getNodeStringValue, "tlp.PropertyInterface.getNodeStringValue(node)\n"
    "\n"
    "Returns a string conversion of the value registered for the given node.\n"
    "\n"
    ":param node: an existing node\n"
    ":type node: :class:`tlp.node`\n"
    ":rtype: string\n"
    ":throws: an exception if the node does not belong to the graph attached to the property");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getNodeStringValue(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getNodeStringValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::node * a0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_node, &a0))
        {
            std::string *sipRes = 0;
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_getNodeStringValue);
                return NULL;
            }

#line 245 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipRes = new std::string(sipCpp->getNodeStringValue(*a0));
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp->getGraph(), *a0);
	}
#line 541 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getNodeStringValue, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_getEdgeStringValue, "tlp.PropertyInterface.getEdgeStringValue(edge)\n"
    "\n"
    "Returns a string conversion of the value registered for the given edge.\n"
    "\n"
    ":param edge: an existing edge\n"
    ":type edge: :class:`tlp.edge`\n"
    ":rtype: string\n"
    ":throws: an exception if the edge does not belong to the graph attached to the property");

extern "C" {static PyObject *meth_tlp_PropertyInterface_getEdgeStringValue(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_getEdgeStringValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::edge * a0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_edge, &a0))
        {
            std::string *sipRes = 0;
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_getEdgeStringValue);
                return NULL;
            }

#line 267 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipRes = new std::string(sipCpp->getEdgeStringValue(*a0));
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp->getGraph(), *a0);
	}
#line 593 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_getEdgeStringValue, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_setNodeStringValue, "tlp.PropertyInterface.setNodeStringValue(node, str)\n"
    "\n"
    "Registers a new value for the given node in converting\n"
    "the given string representation.\n"
    "Returns :const:`True` if the given string representation has been successfully converted to a value, :const:`False` otherwise.\n"
    "\n"
    ":param node: an existing node\n"
    ":type node: :class:`tlp.node`\n"
    ":param str: a string representation of a value\n"
    ":type str: string\n"
    ":rtype: boolean\n"
    ":throws: an exception if the node does not belong to the graph attached to the property");

extern "C" {static PyObject *meth_tlp_PropertyInterface_setNodeStringValue(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_setNodeStringValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::node * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J1", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_node, &a0, sipType_std_string,&a1, &a1State))
        {
            bool sipRes = 0;
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_setNodeStringValue);
                return NULL;
            }

#line 293 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipCpp->setNodeStringValue(*a0, *a1);
	} else {
		sipIsErr = throwInvalidNodeException(sipCpp->getGraph(), *a0);
	}
#line 651 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            if (sipIsErr)
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_setNodeStringValue, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_setEdgeStringValue, "tlp.PropertyInterface.setEdgeStringValue(edge, str)\n"
    "\n"
    "Registers a new value for the given edge in converting\n"
    "the given string representation.\n"
    "Returns :const:`True` if the given string representation has been successfully converted to a value, :const:`False` otherwise.\n"
    "\n"
    ":param edge: an existing edge\n"
    ":type edge: :class:`tlp.edge`\n"
    ":param str: a string representation of a value\n"
    ":type str: string\n"
    ":rtype: boolean\n"
    ":throws: an exception if the edge does not belong to the graph attached to the property");

extern "C" {static PyObject *meth_tlp_PropertyInterface_setEdgeStringValue(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_setEdgeStringValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::edge * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J1", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_edge, &a0, sipType_std_string,&a1, &a1State))
        {
            bool sipRes = 0;
            int sipIsErr = 0;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PropertyInterface, sipName_setEdgeStringValue);
                return NULL;
            }

#line 319 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipCpp->setEdgeStringValue(*a0, *a1);
	} else {
		sipIsErr = throwInvalidEdgeException(sipCpp->getGraph(), *a0);
	}
#line 710 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            if (sipIsErr)
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_setEdgeStringValue, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_addPropertyObserver, "tlp.PropertyInterface.addPropertyObserver(propertyObserver)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Registers a new property observer object\n"
    "that will receive notifications when the property is modified.\n"
    "\n"
    ":param propertyObserver: the new property observer to register\n"
    ":type propertyObserver: :class:`tlp.PropertyObserver`");

extern "C" {static PyObject *meth_tlp_PropertyInterface_addPropertyObserver(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_addPropertyObserver(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::PropertyObserver * a0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_PropertyObserver, &a0))
        {
            sipCpp->addPropertyObserver(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_addPropertyObserver, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_removePropertyObserver, "tlp.PropertyInterface.removePropertyObserver(propertyObserver)\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Removes a registered property observer object.\n"
    "\n"
    ":param propertyObserver: the property observer to remove\n"
    ":type propertyObserver: :class:`tlp.PropertyObserver`");

extern "C" {static PyObject *meth_tlp_PropertyInterface_removePropertyObserver(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_removePropertyObserver(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        tlp::PropertyObserver * a0;
        tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp, sipType_tlp_PropertyObserver, &a0))
        {
            sipCpp->removePropertyObserver(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_removePropertyObserver, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PropertyInterface_countPropertyObservers, "tlp.PropertyInterface.countPropertyObservers()\n"
    "\n"
    ".. versionadded:: 3.8\n"
    "\n"
    "Returns the number of registered property observers.\n"
    "\n"
    ":rtype: integer");

extern "C" {static PyObject *meth_tlp_PropertyInterface_countPropertyObservers(PyObject *, PyObject *);}
static PyObject *meth_tlp_PropertyInterface_countPropertyObservers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::PropertyInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PropertyInterface, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->countPropertyObservers();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName_countPropertyObservers, NULL);

    return NULL;
}


extern "C" {static int slot_tlp_PropertyInterface___setitem__(PyObject *,PyObject *);}
static int slot_tlp_PropertyInterface___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
    tlp::PropertyInterface *sipCpp = reinterpret_cast<tlp::PropertyInterface *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_tlp_PropertyInterface));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;
        const std::string * a1;
        int a1State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J1", sipType_tlp_node, &a0, sipType_std_string,&a1, &a1State))
        {
            int sipIsErr = 0;

#line 384 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipCpp->setNodeStringValue(*a0, *a1);     	
    } else {
    	sipIsErr = throwInvalidNodeException(sipCpp->getGraph(), *a0);
    }
#line 854 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            if (sipIsErr)
                return -1;

            return 0;
        }
    }

    {
        const tlp::edge * a0;
        const std::string * a1;
        int a1State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J1", sipType_tlp_edge, &a0, sipType_std_string,&a1, &a1State))
        {
            int sipIsErr = 0;

#line 407 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipCpp->setEdgeStringValue(*a0, *a1);     	
    } else {
    	sipIsErr = throwInvalidEdgeException(sipCpp->getGraph(), *a0);
    }
#line 879 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            if (sipIsErr)
                return -1;

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_tlp_PropertyInterface___getitem__(PyObject *,PyObject *);}
static PyObject *slot_tlp_PropertyInterface___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
    tlp::PropertyInterface *sipCpp = reinterpret_cast<tlp::PropertyInterface *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_tlp_PropertyInterface));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const tlp::node * a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_tlp_node, &a0))
        {
            std::string *sipRes = 0;
            int sipIsErr = 0;

#line 372 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipRes = new std::string(sipCpp->getNodeStringValue(*a0));     	
    } else {
    	sipIsErr = throwInvalidNodeException(sipCpp->getGraph(), *a0);
    }
#line 920 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    {
        const tlp::edge * a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_tlp_edge, &a0))
        {
            std::string *sipRes = 0;
            int sipIsErr = 0;

#line 395 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PropertyInterface.sip"
	if (sipCpp->getGraph()->isElement(*a0)) {
		sipRes = new std::string(sipCpp->getEdgeStringValue(*a0));     	
    } else {
    	sipIsErr = throwInvalidEdgeException(sipCpp->getGraph(), *a0);
    }
#line 943 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPropertyInterface.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PropertyInterface, sipName___getitem__, NULL);

    return 0;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_tlp_PropertyInterface(void *, const sipTypeDef *);}
static void *cast_tlp_PropertyInterface(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_tlp_PropertyInterface)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_tlp_PropertyInterface(void *, int);}
static void release_tlp_PropertyInterface(void *sipCppV,int)
{
    delete reinterpret_cast<tlp::PropertyInterface *>(sipCppV);
}


extern "C" {static void dealloc_tlp_PropertyInterface(sipSimpleWrapper *);}
static void dealloc_tlp_PropertyInterface(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_tlp_PropertyInterface(sipGetAddress(sipSelf),0);
    }
}


/* Define this type's Python slots. */
static sipPySlotDef slots_tlp_PropertyInterface[] = {
    {(void *)slot_tlp_PropertyInterface___setitem__, setitem_slot},
    {(void *)slot_tlp_PropertyInterface___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_tlp_PropertyInterface[] = {
    {SIP_MLNAME_CAST(sipName_addPropertyObserver), meth_tlp_PropertyInterface_addPropertyObserver, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_addPropertyObserver)},
    {SIP_MLNAME_CAST(sipName_countPropertyObservers), meth_tlp_PropertyInterface_countPropertyObservers, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_countPropertyObservers)},
    {SIP_MLNAME_CAST(sipName_erase), meth_tlp_PropertyInterface_erase, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_erase)},
    {SIP_MLNAME_CAST(sipName_getEdgeDefaultStringValue), meth_tlp_PropertyInterface_getEdgeDefaultStringValue, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getEdgeDefaultStringValue)},
    {SIP_MLNAME_CAST(sipName_getEdgeStringValue), meth_tlp_PropertyInterface_getEdgeStringValue, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getEdgeStringValue)},
    {SIP_MLNAME_CAST(sipName_getGraph), meth_tlp_PropertyInterface_getGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getGraph)},
    {SIP_MLNAME_CAST(sipName_getName), meth_tlp_PropertyInterface_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getName)},
    {SIP_MLNAME_CAST(sipName_getNodeDefaultStringValue), meth_tlp_PropertyInterface_getNodeDefaultStringValue, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getNodeDefaultStringValue)},
    {SIP_MLNAME_CAST(sipName_getNodeStringValue), meth_tlp_PropertyInterface_getNodeStringValue, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getNodeStringValue)},
    {SIP_MLNAME_CAST(sipName_getNonDefaultValuatedEdges), meth_tlp_PropertyInterface_getNonDefaultValuatedEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getNonDefaultValuatedEdges)},
    {SIP_MLNAME_CAST(sipName_getNonDefaultValuatedNodes), meth_tlp_PropertyInterface_getNonDefaultValuatedNodes, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getNonDefaultValuatedNodes)},
    {SIP_MLNAME_CAST(sipName_getTypename), meth_tlp_PropertyInterface_getTypename, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_getTypename)},
    {SIP_MLNAME_CAST(sipName_removePropertyObserver), meth_tlp_PropertyInterface_removePropertyObserver, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_removePropertyObserver)},
    {SIP_MLNAME_CAST(sipName_setAllEdgeStringValue), meth_tlp_PropertyInterface_setAllEdgeStringValue, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_setAllEdgeStringValue)},
    {SIP_MLNAME_CAST(sipName_setAllNodeStringValue), meth_tlp_PropertyInterface_setAllNodeStringValue, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_setAllNodeStringValue)},
    {SIP_MLNAME_CAST(sipName_setEdgeStringValue), meth_tlp_PropertyInterface_setEdgeStringValue, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_setEdgeStringValue)},
    {SIP_MLNAME_CAST(sipName_setNodeStringValue), meth_tlp_PropertyInterface_setNodeStringValue, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PropertyInterface_setNodeStringValue)}
};


sipClassTypeDef sipTypeDef_tulip_tlp_PropertyInterface = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_tlp__PropertyInterface,
        {0}
    },
    {
        sipNameNr_PropertyInterface,
        {21, 255, 0},
        17, methods_tlp_PropertyInterface,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    0,
    -1,
    -1,
    0,
    slots_tlp_PropertyInterface,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_tlp_PropertyInterface,
    0,
    0,
    0,
    release_tlp_PropertyInterface,
    cast_tlp_PropertyInterface,
    0,
    0,
    0
};

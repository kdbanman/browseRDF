/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Fri Apr 26 16:33:30 2013
 */

#include "sipAPItulip.h"

#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 24 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/ObservableGraph.sip"
#include <tulip/ObservableGraph.h>
#line 26 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraphObserver.cpp"

#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 112 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/Graph.sip"
#include <tulip/Graph.h>
#line 44 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraphObserver.cpp"
#line 29 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/../stl/string.sip"
	// Include the library interface to the type being mapped.
#include <string>
#line 48 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraphObserver.cpp"
#line 30 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/Edge.sip"
#include <tulip/tulipconf.h>
#include <tulip/Edge.h>
#line 52 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraphObserver.cpp"
#line 29 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/Node.sip"
#include <tulip/Node.h>
#line 55 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpGraphObserver.cpp"


class siptlp_GraphObserver : public tlp::GraphObserver
{
public:
    siptlp_GraphObserver();
    siptlp_GraphObserver(const tlp::GraphObserver&);
    virtual ~siptlp_GraphObserver();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void addNode(tlp::Graph *,const tlp::node);
    void addEdge(tlp::Graph *,const tlp::edge);
    void beforeSetEnds(tlp::Graph *,const tlp::edge);
    void afterSetEnds(tlp::Graph *,const tlp::edge);
    void delNode(tlp::Graph *,const tlp::node);
    void delEdge(tlp::Graph *,const tlp::edge);
    void reverseEdge(tlp::Graph *,const tlp::edge);
    void destroy(tlp::Graph *);
    void addSubGraph(tlp::Graph *,tlp::Graph *);
    void delSubGraph(tlp::Graph *,tlp::Graph *);
    void addLocalProperty(tlp::Graph *,const std::string&);
    void beforeDelLocalProperty(tlp::Graph *,const std::string&);
    void afterDelLocalProperty(tlp::Graph *,const std::string&);
    void addInheritedProperty(tlp::Graph *,const std::string&);
    void beforeDelInheritedProperty(tlp::Graph *,const std::string&);
    void afterDelInheritedProperty(tlp::Graph *,const std::string&);
    void beforeSetAttribute(tlp::Graph *,const std::string&);
    void afterSetAttribute(tlp::Graph *,const std::string&);
    void removeAttribute(tlp::Graph *,const std::string&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    siptlp_GraphObserver(const siptlp_GraphObserver &);
    siptlp_GraphObserver &operator = (const siptlp_GraphObserver &);

    char sipPyMethods[19];
};

siptlp_GraphObserver::siptlp_GraphObserver(): tlp::GraphObserver(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

siptlp_GraphObserver::siptlp_GraphObserver(const tlp::GraphObserver& a0): tlp::GraphObserver(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

siptlp_GraphObserver::~siptlp_GraphObserver()
{
    sipCommonDtor(sipPySelf);
}

void siptlp_GraphObserver::addNode(tlp::Graph *a0,const tlp::node a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_addNode);

    if (!sipMeth)
    {
        tlp::GraphObserver::addNode(a0,a1);
        return;
    }

    extern void sipVH_tulip_12(sip_gilstate_t,PyObject *,tlp::Graph *,const tlp::node);

    sipVH_tulip_12(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::addEdge(tlp::Graph *a0,const tlp::edge a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_addEdge);

    if (!sipMeth)
    {
        tlp::GraphObserver::addEdge(a0,a1);
        return;
    }

    extern void sipVH_tulip_11(sip_gilstate_t,PyObject *,tlp::Graph *,const tlp::edge);

    sipVH_tulip_11(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::beforeSetEnds(tlp::Graph *a0,const tlp::edge a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_beforeSetEnds);

    if (!sipMeth)
    {
        tlp::GraphObserver::beforeSetEnds(a0,a1);
        return;
    }

    extern void sipVH_tulip_11(sip_gilstate_t,PyObject *,tlp::Graph *,const tlp::edge);

    sipVH_tulip_11(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::afterSetEnds(tlp::Graph *a0,const tlp::edge a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_afterSetEnds);

    if (!sipMeth)
    {
        tlp::GraphObserver::afterSetEnds(a0,a1);
        return;
    }

    extern void sipVH_tulip_11(sip_gilstate_t,PyObject *,tlp::Graph *,const tlp::edge);

    sipVH_tulip_11(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::delNode(tlp::Graph *a0,const tlp::node a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_delNode);

    if (!sipMeth)
    {
        tlp::GraphObserver::delNode(a0,a1);
        return;
    }

    extern void sipVH_tulip_12(sip_gilstate_t,PyObject *,tlp::Graph *,const tlp::node);

    sipVH_tulip_12(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::delEdge(tlp::Graph *a0,const tlp::edge a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_delEdge);

    if (!sipMeth)
    {
        tlp::GraphObserver::delEdge(a0,a1);
        return;
    }

    extern void sipVH_tulip_11(sip_gilstate_t,PyObject *,tlp::Graph *,const tlp::edge);

    sipVH_tulip_11(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::reverseEdge(tlp::Graph *a0,const tlp::edge a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_reverseEdge);

    if (!sipMeth)
    {
        tlp::GraphObserver::reverseEdge(a0,a1);
        return;
    }

    extern void sipVH_tulip_11(sip_gilstate_t,PyObject *,tlp::Graph *,const tlp::edge);

    sipVH_tulip_11(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::destroy(tlp::Graph *a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[7],sipPySelf,NULL,sipName_destroy);

    if (!sipMeth)
    {
        tlp::GraphObserver::destroy(a0);
        return;
    }

    extern void sipVH_tulip_10(sip_gilstate_t,PyObject *,tlp::Graph *);

    sipVH_tulip_10(sipGILState,sipMeth,a0);
}

void siptlp_GraphObserver::addSubGraph(tlp::Graph *a0,tlp::Graph *a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,NULL,sipName_addSubGraph);

    if (!sipMeth)
    {
        tlp::GraphObserver::addSubGraph(a0,a1);
        return;
    }

    extern void sipVH_tulip_9(sip_gilstate_t,PyObject *,tlp::Graph *,tlp::Graph *);

    sipVH_tulip_9(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::delSubGraph(tlp::Graph *a0,tlp::Graph *a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[9],sipPySelf,NULL,sipName_delSubGraph);

    if (!sipMeth)
    {
        tlp::GraphObserver::delSubGraph(a0,a1);
        return;
    }

    extern void sipVH_tulip_9(sip_gilstate_t,PyObject *,tlp::Graph *,tlp::Graph *);

    sipVH_tulip_9(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::addLocalProperty(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[10],sipPySelf,NULL,sipName_addLocalProperty);

    if (!sipMeth)
    {
        tlp::GraphObserver::addLocalProperty(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::beforeDelLocalProperty(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[11],sipPySelf,NULL,sipName_beforeDelLocalProperty);

    if (!sipMeth)
    {
        tlp::GraphObserver::beforeDelLocalProperty(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::afterDelLocalProperty(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[12],sipPySelf,NULL,sipName_afterDelLocalProperty);

    if (!sipMeth)
    {
        tlp::GraphObserver::afterDelLocalProperty(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::addInheritedProperty(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,NULL,sipName_addInheritedProperty);

    if (!sipMeth)
    {
        tlp::GraphObserver::addInheritedProperty(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::beforeDelInheritedProperty(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[14],sipPySelf,NULL,sipName_beforeDelInheritedProperty);

    if (!sipMeth)
    {
        tlp::GraphObserver::beforeDelInheritedProperty(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::afterDelInheritedProperty(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[15],sipPySelf,NULL,sipName_afterDelInheritedProperty);

    if (!sipMeth)
    {
        tlp::GraphObserver::afterDelInheritedProperty(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::beforeSetAttribute(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[16],sipPySelf,NULL,sipName_beforeSetAttribute);

    if (!sipMeth)
    {
        tlp::GraphObserver::beforeSetAttribute(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::afterSetAttribute(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[17],sipPySelf,NULL,sipName_afterSetAttribute);

    if (!sipMeth)
    {
        tlp::GraphObserver::afterSetAttribute(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}

void siptlp_GraphObserver::removeAttribute(tlp::Graph *a0,const std::string& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[18],sipPySelf,NULL,sipName_removeAttribute);

    if (!sipMeth)
    {
        tlp::GraphObserver::removeAttribute(a0,a1);
        return;
    }

    extern void sipVH_tulip_8(sip_gilstate_t,PyObject *,tlp::Graph *,const std::string&);

    sipVH_tulip_8(sipGILState,sipMeth,a0,a1);
}


PyDoc_STRVAR(doc_tlp_GraphObserver_addNode, "tlp.GraphObserver.addNode(graph, node)\n"
    "\n"
    "This method is called each time a node is added\n"
    "in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param node: the newly added node\n"
    ":type node: :class:`tlp.node`");

extern "C" {static PyObject *meth_tlp_GraphObserver_addNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_addNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const tlp::node * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J9", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_node, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::addNode(a0,*a1) : sipCpp->addNode(a0,*a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_addNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_addEdge, "tlp.GraphObserver.addEdge(graph, edge)\n"
    "\n"
    "This method is called each time an edge is added\n"
    "in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param edge: the newly added edge\n"
    ":type edge: :class:`tlp.edge`");

extern "C" {static PyObject *meth_tlp_GraphObserver_addEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_addEdge(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const tlp::edge * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J9", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_edge, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::addEdge(a0,*a1) : sipCpp->addEdge(a0,*a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_addEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_beforeSetEnds, "tlp.GraphObserver.beforeSetEnds(graph, edge)\n"
    "\n"
    "This method is called before the modification of the\n"
    "ends of an edge in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param edge: the edge whose ends will be modified\n"
    ":type edge: :class:`tlp.edge`");

extern "C" {static PyObject *meth_tlp_GraphObserver_beforeSetEnds(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_beforeSetEnds(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const tlp::edge * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J9", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_edge, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::beforeSetEnds(a0,*a1) : sipCpp->beforeSetEnds(a0,*a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_beforeSetEnds, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_afterSetEnds, "tlp.GraphObserver.afterSetEnds(graph, edge)\n"
    "\n"
    "This method is called after the modification of the\n"
    "ends of an edge in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param edge: the edge whose ends have been modified\n"
    ":type edge: :class:`tlp.edge`");

extern "C" {static PyObject *meth_tlp_GraphObserver_afterSetEnds(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_afterSetEnds(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const tlp::edge * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J9", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_edge, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::afterSetEnds(a0,*a1) : sipCpp->afterSetEnds(a0,*a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_afterSetEnds, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_delNode, "tlp.GraphObserver.delNode(graph, node)\n"
    "\n"
    "This method is called each time a node is deleted\n"
    "in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param node: the deleted node\n"
    ":type node: :class:`tlp.node`");

extern "C" {static PyObject *meth_tlp_GraphObserver_delNode(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_delNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const tlp::node * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J9", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_node, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::delNode(a0,*a1) : sipCpp->delNode(a0,*a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_delNode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_delEdge, "tlp.GraphObserver.delEdge(graph, edge)\n"
    "\n"
    "This method is called each time an edge is deleted\n"
    "in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param edge: the deleted edge\n"
    ":type edge: :class:`tlp.edge`");

extern "C" {static PyObject *meth_tlp_GraphObserver_delEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_delEdge(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const tlp::edge * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J9", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_edge, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::delEdge(a0,*a1) : sipCpp->delEdge(a0,*a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_delEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_reverseEdge, "tlp.GraphObserver.reverseEdge(graph, edge)\n"
    "\n"
    "This method is called each time the orientation of an edge is reversed\n"
    "in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param edge: the reversed edge\n"
    ":type edge: :class:`tlp.edge`");

extern "C" {static PyObject *meth_tlp_GraphObserver_reverseEdge(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_reverseEdge(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const tlp::edge * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J9", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_edge, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::reverseEdge(a0,*a1) : sipCpp->reverseEdge(a0,*a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_reverseEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_destroy, "tlp.GraphObserver.destroy(graph)\n"
    "\n"
    "This method is called when an observed graph is deleted.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_GraphObserver_destroy(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_destroy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::destroy(a0) : sipCpp->destroy(a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_destroy, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_addSubGraph, "tlp.GraphObserver.addSubGraph(graph, subgraph)\n"
    "\n"
    "This method is called each time a sub-graph is added\n"
    "in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param subgraph: the newly added sub-graph\n"
    ":type subgraph: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_GraphObserver_addSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_addSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        tlp::Graph * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J8", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_Graph, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::addSubGraph(a0,a1) : sipCpp->addSubGraph(a0,a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_addSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_delSubGraph, "tlp.GraphObserver.delSubGraph(graph, subgraph)\n"
    "\n"
    "This method is called each time a sub-graph is deleted\n"
    "in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param subgraph: the deleted sub-graph\n"
    ":type subgraph: :class:`tlp.Graph`");

extern "C" {static PyObject *meth_tlp_GraphObserver_delSubGraph(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_delSubGraph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        tlp::Graph * a1;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J8", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_tlp_Graph, &a1))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::delSubGraph(a0,a1) : sipCpp->delSubGraph(a0,a1));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_delSubGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_addLocalProperty, "tlp.GraphObserver.addLocalProperty(graph, propertyName)\n"
    "\n"
    "This method is called each time a new local property\n"
    "is attached to an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param propertyName: the name of the new local property\n"
    ":type propertyName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_addLocalProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_addLocalProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::addLocalProperty(a0,*a1) : sipCpp->addLocalProperty(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_addLocalProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_beforeDelLocalProperty, "tlp.GraphObserver.beforeDelLocalProperty(graph, propertyName)\n"
    "\n"
    "This method is called before the deletion\n"
    "of a local property attached to an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param propertyName: the name of the local property that will be deleted\n"
    ":type propertyName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_beforeDelLocalProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_beforeDelLocalProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::beforeDelLocalProperty(a0,*a1) : sipCpp->beforeDelLocalProperty(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_beforeDelLocalProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_afterDelLocalProperty, "tlp.GraphObserver.afterDelLocalProperty(graph, propertyName)\n"
    "\n"
    "This method is called after the deletion\n"
    "of a local property attached to an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param propertyName: the name of the local property that has been deleted\n"
    ":type propertyName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_afterDelLocalProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_afterDelLocalProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::afterDelLocalProperty(a0,*a1) : sipCpp->afterDelLocalProperty(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_afterDelLocalProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_addInheritedProperty, "tlp.GraphObserver.addInheritedProperty(graph, propertyName)\n"
    "\n"
    "This method is called each time a new inherited property\n"
    "is attached to an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param propertyName: the name of the new inherited property\n"
    ":type propertyName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_addInheritedProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_addInheritedProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::addInheritedProperty(a0,*a1) : sipCpp->addInheritedProperty(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_addInheritedProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_beforeDelInheritedProperty, "tlp.GraphObserver.beforeDelInheritedProperty(graph, propertyName)\n"
    "\n"
    "This method is called before the deletion\n"
    "of an inherited property attached to an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param propertyName: the name of the inherited property that will be deleted\n"
    ":type propertyName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_beforeDelInheritedProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_beforeDelInheritedProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::beforeDelInheritedProperty(a0,*a1) : sipCpp->beforeDelInheritedProperty(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_beforeDelInheritedProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_afterDelInheritedProperty, "tlp.GraphObserver.afterDelInheritedProperty(graph, propertyName)\n"
    "\n"
    "This method is called after the deletion\n"
    "of an inherited property attached to an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param propertyName: the name of the inherited property that has been deleted\n"
    ":type propertyName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_afterDelInheritedProperty(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_afterDelInheritedProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::afterDelInheritedProperty(a0,*a1) : sipCpp->afterDelInheritedProperty(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_afterDelInheritedProperty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_beforeSetAttribute, "tlp.GraphObserver.beforeSetAttribute(graph, attributeName)\n"
    "\n"
    "This method is called before the creation/modification of\n"
    "an attribute in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param attributeName: the name of the attribute that will be created/modified\n"
    ":type attributeName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_beforeSetAttribute(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_beforeSetAttribute(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::beforeSetAttribute(a0,*a1) : sipCpp->beforeSetAttribute(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_beforeSetAttribute, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_afterSetAttribute, "tlp.GraphObserver.afterSetAttribute(graph, attributeName)\n"
    "\n"
    "This method is called after the creation/modification of\n"
    "an attribute in an observed graph.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param attributeName: the name of the attribute that has been created/modified\n"
    ":type attributeName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_afterSetAttribute(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_afterSetAttribute(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::afterSetAttribute(a0,*a1) : sipCpp->afterSetAttribute(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_afterSetAttribute, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_GraphObserver_removeAttribute, "tlp.GraphObserver.removeAttribute(graph, attributeName)\n"
    "\n"
    "This method is called each time an attribute of an observed graph\n"
    "is removed.\n"
    "\n"
    ":param graph: the observed graph\n"
    ":type graph: :class:`tlp.Graph`\n"
    ":param attributeName: the name of the removed attribute\n"
    ":type attributeName: string");

extern "C" {static PyObject *meth_tlp_GraphObserver_removeAttribute(PyObject *, PyObject *);}
static PyObject *meth_tlp_GraphObserver_removeAttribute(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        tlp::Graph * a0;
        const std::string * a1;
        int a1State = 0;
        tlp::GraphObserver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J1", &sipSelf, sipType_tlp_GraphObserver, &sipCpp, sipType_tlp_Graph, &a0, sipType_std_string,&a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp->tlp::GraphObserver::removeAttribute(a0,*a1) : sipCpp->removeAttribute(a0,*a1));
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GraphObserver, sipName_removeAttribute, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_tlp_GraphObserver(void *, const sipTypeDef *);}
static void *cast_tlp_GraphObserver(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_tlp_GraphObserver)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_tlp_GraphObserver(void *, int);}
static void release_tlp_GraphObserver(void *sipCppV,int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<siptlp_GraphObserver *>(sipCppV);
    else
        delete reinterpret_cast<tlp::GraphObserver *>(sipCppV);
}


extern "C" {static void assign_tlp_GraphObserver(void *, SIP_SSIZE_T, const void *);}
static void assign_tlp_GraphObserver(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<tlp::GraphObserver *>(sipDst)[sipDstIdx] = *reinterpret_cast<const tlp::GraphObserver *>(sipSrc);
}


extern "C" {static void *array_tlp_GraphObserver(SIP_SSIZE_T);}
static void *array_tlp_GraphObserver(SIP_SSIZE_T sipNrElem)
{
    return new tlp::GraphObserver[sipNrElem];
}


extern "C" {static void *copy_tlp_GraphObserver(const void *, SIP_SSIZE_T);}
static void *copy_tlp_GraphObserver(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new tlp::GraphObserver(reinterpret_cast<const tlp::GraphObserver *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_tlp_GraphObserver(sipSimpleWrapper *);}
static void dealloc_tlp_GraphObserver(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<siptlp_GraphObserver *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_tlp_GraphObserver(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_tlp_GraphObserver(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_tlp_GraphObserver(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    siptlp_GraphObserver *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new siptlp_GraphObserver();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const tlp::GraphObserver * a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_tlp_GraphObserver, &a0))
        {
            sipCpp = new siptlp_GraphObserver(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_tlp_GraphObserver[] = {
    {SIP_MLNAME_CAST(sipName_addEdge), meth_tlp_GraphObserver_addEdge, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_addEdge)},
    {SIP_MLNAME_CAST(sipName_addInheritedProperty), meth_tlp_GraphObserver_addInheritedProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_addInheritedProperty)},
    {SIP_MLNAME_CAST(sipName_addLocalProperty), meth_tlp_GraphObserver_addLocalProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_addLocalProperty)},
    {SIP_MLNAME_CAST(sipName_addNode), meth_tlp_GraphObserver_addNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_addNode)},
    {SIP_MLNAME_CAST(sipName_addSubGraph), meth_tlp_GraphObserver_addSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_addSubGraph)},
    {SIP_MLNAME_CAST(sipName_afterDelInheritedProperty), meth_tlp_GraphObserver_afterDelInheritedProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_afterDelInheritedProperty)},
    {SIP_MLNAME_CAST(sipName_afterDelLocalProperty), meth_tlp_GraphObserver_afterDelLocalProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_afterDelLocalProperty)},
    {SIP_MLNAME_CAST(sipName_afterSetAttribute), meth_tlp_GraphObserver_afterSetAttribute, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_afterSetAttribute)},
    {SIP_MLNAME_CAST(sipName_afterSetEnds), meth_tlp_GraphObserver_afterSetEnds, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_afterSetEnds)},
    {SIP_MLNAME_CAST(sipName_beforeDelInheritedProperty), meth_tlp_GraphObserver_beforeDelInheritedProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_beforeDelInheritedProperty)},
    {SIP_MLNAME_CAST(sipName_beforeDelLocalProperty), meth_tlp_GraphObserver_beforeDelLocalProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_beforeDelLocalProperty)},
    {SIP_MLNAME_CAST(sipName_beforeSetAttribute), meth_tlp_GraphObserver_beforeSetAttribute, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_beforeSetAttribute)},
    {SIP_MLNAME_CAST(sipName_beforeSetEnds), meth_tlp_GraphObserver_beforeSetEnds, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_beforeSetEnds)},
    {SIP_MLNAME_CAST(sipName_delEdge), meth_tlp_GraphObserver_delEdge, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_delEdge)},
    {SIP_MLNAME_CAST(sipName_delNode), meth_tlp_GraphObserver_delNode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_delNode)},
    {SIP_MLNAME_CAST(sipName_delSubGraph), meth_tlp_GraphObserver_delSubGraph, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_delSubGraph)},
    {SIP_MLNAME_CAST(sipName_destroy), meth_tlp_GraphObserver_destroy, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_destroy)},
    {SIP_MLNAME_CAST(sipName_removeAttribute), meth_tlp_GraphObserver_removeAttribute, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_removeAttribute)},
    {SIP_MLNAME_CAST(sipName_reverseEdge), meth_tlp_GraphObserver_reverseEdge, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_GraphObserver_reverseEdge)}
};

PyDoc_STRVAR(doc_tlp_GraphObserver, ".. versionadded:: 3.8\n"
    "\n"
    "Derived implementation of that class receives a message (through a callback/handler method)\n"
    "after each modification of a :class:`tlp.Graph` object.\n"
    "\n"
    "To receive notifications, the :class:`tlp.GraphObserver` object must\n"
    "first be connected to the :class:`tlp.Graph` object.\n"
    "This is done by calling the :meth:`tlp.Graph.addGraphObserver` method.\n"
    "\n"
    "Depending on which messages you want to receive, you need to override\n"
    "different methods of :class:`tlp.GraphObserver`.\n"
    "\n"
    "The Observer pattern is described in the lecture notes and pp293-304\n"
    "of Design Patterns by Gamma, Helm, Johnson, and Vlissides. It is a\n"
    "framework for handling state dependency between observer and observed\n"
    "object.\n"
    "\n"
    "Below is a small example of an observer that displays a message on the\n"
    "standard output each time a node is added to a graph::\n"
    "\n"
    "    class PrintObs(tlp.GraphObserver):\n"
    "        def addNode(self, graph, node):\n"
    "            print node, \" added in \", graph\n"
    "\n"
    "    printObs = PrintObs()\n"
    "\n"
    "    def main(graph):\n"
    "        graph.addGraphObserver(printObs)\n"
    "        graph.addNode() // output : \"<node ?> added in <graph ?>\"\n"
    "\n"
    "");


sipClassTypeDef sipTypeDef_tulip_tlp_GraphObserver = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_tlp__GraphObserver,
        {0}
    },
    {
        sipNameNr_GraphObserver,
        {21, 255, 0},
        19, methods_tlp_GraphObserver,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_tlp_GraphObserver,
    -1,
    -1,
    0,
    0,
    init_tlp_GraphObserver,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_tlp_GraphObserver,
    assign_tlp_GraphObserver,
    array_tlp_GraphObserver,
    copy_tlp_GraphObserver,
    release_tlp_GraphObserver,
    cast_tlp_GraphObserver,
    0,
    0,
    0
};

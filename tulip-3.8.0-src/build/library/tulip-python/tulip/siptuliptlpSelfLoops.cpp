/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Mon Apr 29 01:46:10 2013
 */

#include "sipAPItulip.h"

#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/AcyclicTest.sip"
#include <tulip/AcyclicTest.h>
#line 26 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpSelfLoops.cpp"

#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Edge.sip"
#include <tulip/tulipconf.h>
#include <tulip/Edge.h>
#line 31 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpSelfLoops.cpp"
#line 29 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip/Node.sip"
#include <tulip/Node.h>
#line 34 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpSelfLoops.cpp"


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_tlp_SelfLoops(void *, const sipTypeDef *);}
static void *cast_tlp_SelfLoops(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_tlp_SelfLoops)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_tlp_SelfLoops(void *, int);}
static void release_tlp_SelfLoops(void *sipCppV,int)
{
    delete reinterpret_cast<tlp::SelfLoops *>(sipCppV);
}


extern "C" {static void dealloc_tlp_SelfLoops(sipSimpleWrapper *);}
static void dealloc_tlp_SelfLoops(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_tlp_SelfLoops(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_tlp_SelfLoops(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_tlp_SelfLoops(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    tlp::SelfLoops *sipCpp = 0;

    {
        tlp::node * a0;
        tlp::node * a1;
        tlp::edge * a2;
        tlp::edge * a3;
        tlp::edge * a4;
        tlp::edge * a5;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9J9J9J9J9J9", sipType_tlp_node, &a0, sipType_tlp_node, &a1, sipType_tlp_edge, &a2, sipType_tlp_edge, &a3, sipType_tlp_edge, &a4, sipType_tlp_edge, &a5))
        {
            sipCpp = new tlp::SelfLoops(*a0,*a1,*a2,*a3,*a4,*a5);

            return sipCpp;
        }
    }

    {
        const tlp::SelfLoops * a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_tlp_SelfLoops, &a0))
        {
            sipCpp = new tlp::SelfLoops(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static PyObject *varget_tlp_SelfLoops_e1(void *, PyObject *);}
static PyObject *varget_tlp_SelfLoops_e1(void *sipSelf, PyObject *)
{
    tlp::edge *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    sipVal = &sipCpp->e1;

    return sipConvertFromType(sipVal,sipType_tlp_edge, NULL);
}


extern "C" {static int varset_tlp_SelfLoops_e1(void *, PyObject *, PyObject *);}
static int varset_tlp_SelfLoops_e1(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::edge *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::edge *>(sipForceConvertToType(sipPy,sipType_tlp_edge,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->e1 = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_tlp_SelfLoops_e2(void *, PyObject *);}
static PyObject *varget_tlp_SelfLoops_e2(void *sipSelf, PyObject *)
{
    tlp::edge *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    sipVal = &sipCpp->e2;

    return sipConvertFromType(sipVal,sipType_tlp_edge, NULL);
}


extern "C" {static int varset_tlp_SelfLoops_e2(void *, PyObject *, PyObject *);}
static int varset_tlp_SelfLoops_e2(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::edge *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::edge *>(sipForceConvertToType(sipPy,sipType_tlp_edge,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->e2 = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_tlp_SelfLoops_e3(void *, PyObject *);}
static PyObject *varget_tlp_SelfLoops_e3(void *sipSelf, PyObject *)
{
    tlp::edge *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    sipVal = &sipCpp->e3;

    return sipConvertFromType(sipVal,sipType_tlp_edge, NULL);
}


extern "C" {static int varset_tlp_SelfLoops_e3(void *, PyObject *, PyObject *);}
static int varset_tlp_SelfLoops_e3(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::edge *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::edge *>(sipForceConvertToType(sipPy,sipType_tlp_edge,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->e3 = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_tlp_SelfLoops_n1(void *, PyObject *);}
static PyObject *varget_tlp_SelfLoops_n1(void *sipSelf, PyObject *)
{
    tlp::node *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    sipVal = &sipCpp->n1;

    return sipConvertFromType(sipVal,sipType_tlp_node, NULL);
}


extern "C" {static int varset_tlp_SelfLoops_n1(void *, PyObject *, PyObject *);}
static int varset_tlp_SelfLoops_n1(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::node *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::node *>(sipForceConvertToType(sipPy,sipType_tlp_node,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->n1 = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_tlp_SelfLoops_n2(void *, PyObject *);}
static PyObject *varget_tlp_SelfLoops_n2(void *sipSelf, PyObject *)
{
    tlp::node *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    sipVal = &sipCpp->n2;

    return sipConvertFromType(sipVal,sipType_tlp_node, NULL);
}


extern "C" {static int varset_tlp_SelfLoops_n2(void *, PyObject *, PyObject *);}
static int varset_tlp_SelfLoops_n2(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::node *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::node *>(sipForceConvertToType(sipPy,sipType_tlp_node,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->n2 = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_tlp_SelfLoops_old(void *, PyObject *);}
static PyObject *varget_tlp_SelfLoops_old(void *sipSelf, PyObject *)
{
    tlp::edge *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    sipVal = &sipCpp->old;

    return sipConvertFromType(sipVal,sipType_tlp_edge, NULL);
}


extern "C" {static int varset_tlp_SelfLoops_old(void *, PyObject *, PyObject *);}
static int varset_tlp_SelfLoops_old(void *sipSelf, PyObject *sipPy, PyObject *)
{
    tlp::edge *sipVal;
    tlp::SelfLoops *sipCpp = reinterpret_cast<tlp::SelfLoops *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<tlp::edge *>(sipForceConvertToType(sipPy,sipType_tlp_edge,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->old = *sipVal;

    return 0;
}

sipVariableDef variables_tlp_SelfLoops[] = {
    {InstanceVariable, sipName_e1, (PyMethodDef *)varget_tlp_SelfLoops_e1, (PyMethodDef *)varset_tlp_SelfLoops_e1, NULL, NULL},
    {InstanceVariable, sipName_e2, (PyMethodDef *)varget_tlp_SelfLoops_e2, (PyMethodDef *)varset_tlp_SelfLoops_e2, NULL, NULL},
    {InstanceVariable, sipName_e3, (PyMethodDef *)varget_tlp_SelfLoops_e3, (PyMethodDef *)varset_tlp_SelfLoops_e3, NULL, NULL},
    {InstanceVariable, sipName_n1, (PyMethodDef *)varget_tlp_SelfLoops_n1, (PyMethodDef *)varset_tlp_SelfLoops_n1, NULL, NULL},
    {InstanceVariable, sipName_n2, (PyMethodDef *)varget_tlp_SelfLoops_n2, (PyMethodDef *)varset_tlp_SelfLoops_n2, NULL, NULL},
    {InstanceVariable, sipName_old, (PyMethodDef *)varget_tlp_SelfLoops_old, (PyMethodDef *)varset_tlp_SelfLoops_old, NULL, NULL},
};

PyDoc_STRVAR(doc_tlp_SelfLoops, "The tlp.SelfLoops class represents a self loop that has been replaced by two nodes and three edges.\n"
    "The method :meth:`tlp.AcyclicTest.makeAcyclic` returns a list of this type.\n"
    " \n"
    "It contains the following variables :\n"
    "\n"
    "* old (:class:`tlp.edge`) : the self loop edge that has been replaced\n"
    "* n1 (:class:`tlp.node`) : the first node added\n"
    "* n2 (:class:`tlp.node`) : the second node added\n"
    "* e1 (:class:`tlp.edge`) : the edge added between the node at the extremity of the loop and n1\n"
    "* e2 (:class:`tlp.edge`) : the edge added between n1 and n2\n"
    "* e3 (:class:`tlp.edge`) : the edge added between the node at the extremity of the loop and n2\n"
    "");


sipClassTypeDef sipTypeDef_tulip_tlp_SelfLoops = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_tlp__SelfLoops,
        {0}
    },
    {
        sipNameNr_SelfLoops,
        {21, 255, 0},
        0, 0,
        0, 0,
        6, variables_tlp_SelfLoops,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_tlp_SelfLoops,
    -1,
    -1,
    0,
    0,
    init_tlp_SelfLoops,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_tlp_SelfLoops,
    0,
    0,
    0,
    release_tlp_SelfLoops,
    cast_tlp_SelfLoops,
    0,
    0,
    0
};

/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Fri Apr 26 16:33:30 2013
 */

#include "sipAPItulip.h"

#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 24 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPluginProgress.cpp"

#line 29 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/../stl/string.sip"
	// Include the library interface to the type being mapped.
#include <string>
#line 29 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPluginProgress.cpp"
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithParameter.sip"
#include <tulip/WithParameter.h>
#include <tulip/ColorScale.h>
#include <tulip/StringCollection.h>
#include <tulip/IntegerProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/DoubleProperty.h>
#include <tulip/BooleanProperty.h>
#include <tulip/ColorProperty.h>
#line 28 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/WithDependency.sip"
#include <tulip/WithDependency.h>
#line 31 "/home/kdbanman/Desktop/tulip-3.8.0-src/library/tulip-python/tulip/PluginProgress.sip"
#include <tulip/PluginProgress.h>
#line 44 "/home/kdbanman/Desktop/tulip-3.8.0-src/build/library/tulip-python/tulip/siptuliptlpPluginProgress.cpp"


PyDoc_STRVAR(doc_tlp_PluginProgress_progress, "tlp.PluginProgress.progress(step, maxStep)\n"
    "\n"
    "Use this method to notify the progression of the process.\n"
    "\n"
    ":param step: the current step number\n"
    ":type step: integer\n"
    ":param maxStep: the total number of steps\n"
    ":type maxStep: integer\n"
    ":rtype: a value indicating whether the progress has been stopped (:const:`tlp.TLP_STOP`), cancelled (:const:`tlp.TLP_CANCEL`), or will continue (:const:`tlp.TLP_CONTINUE`).");

extern "C" {static PyObject *meth_tlp_PluginProgress_progress(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_progress(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        int a0;
        int a1;
        tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bii", &sipSelf, sipType_tlp_PluginProgress, &sipCpp, &a0, &a1))
        {
            tlp::ProgressState sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_progress);
                return NULL;
            }

            sipRes = sipCpp->progress(a0,a1);

            return sipConvertFromEnum(sipRes,sipType_tlp_ProgressState);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_progress, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_cancel, "tlp.PluginProgress.cancel()\n"
    "\n"
    "Sets the state flag to cancel, notifying to the process that the user wants to cancel it.\n"
    "Canceling a process must stop it and revert all the changes performed since its start.");

extern "C" {static PyObject *meth_tlp_PluginProgress_cancel(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_cancel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PluginProgress, &sipCpp))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_cancel);
                return NULL;
            }

            sipCpp->cancel();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_cancel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_stop, "tlp.PluginProgress.stop()\n"
    "\n"
    "Sets the state flag to stop, notifying to the process that the user wants to stop it.\n"
    "Stopping a process does not revert changes.");

extern "C" {static PyObject *meth_tlp_PluginProgress_stop(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_stop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PluginProgress, &sipCpp))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_stop);
                return NULL;
            }

            sipCpp->stop();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_stop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_isPreviewMode, "tlp.PluginProgress.isPreviewMode()\n"
    "\n"
    "Returns :const:`True` if the preview mode is enabled. \n"
    "The preview mode redraws the graph while applying the algorithm, making it slower.\n"
    "\n"
    ":rtype: boolean");

extern "C" {static PyObject *meth_tlp_PluginProgress_isPreviewMode(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_isPreviewMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PluginProgress, &sipCpp))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_isPreviewMode);
                return NULL;
            }

            sipRes = sipCpp->isPreviewMode();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_isPreviewMode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_setPreviewMode, "tlp.PluginProgress.setPreviewMode(preview)\n"
    "\n"
    "Enables / disables the preview mode.\n"
    "The preview mode redraws the graph while applying the algorithm, making it slower.\n"
    "\n"
    ":param preview: indicates if the preview mode should be activated\n"
    ":type preview: boolean");

extern "C" {static PyObject *meth_tlp_PluginProgress_setPreviewMode(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_setPreviewMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        bool a0;
        tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_tlp_PluginProgress, &sipCpp, &a0))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_setPreviewMode);
                return NULL;
            }

            sipCpp->setPreviewMode(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_setPreviewMode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_showPreview, "tlp.PluginProgress.showPreview(showPreview)\n"
    "\n"
    "This tells the widget associated to this PluginProgress if it should show a preview checkbox, \n"
    "allowing the user to decide if the algorithm should draw a preview or not.\n"
    "\n"
    ":param showPreview: whether the progress widget should contain a preview checkbox or not.\n"
    ":type showPreview: boolean");

extern "C" {static PyObject *meth_tlp_PluginProgress_showPreview(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_showPreview(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        bool a0;
        tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_tlp_PluginProgress, &sipCpp, &a0))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_showPreview);
                return NULL;
            }

            sipCpp->showPreview(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_showPreview, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_state, "tlp.PluginProgress.state()\n"
    "\n"
    "Gets the current internal state of the PluginProgress.\n"
    "\n"
    ":rtype: a value indicating whether the progress has been stopped (:const:`tlp.TLP_STOP`), cancelled (:const:`tlp.TLP_CANCEL`), or will continue (:const:`tlp.TLP_CONTINUE`).");

extern "C" {static PyObject *meth_tlp_PluginProgress_state(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_state(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PluginProgress, &sipCpp))
        {
            tlp::ProgressState sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_state);
                return NULL;
            }

            sipRes = sipCpp->state();

            return sipConvertFromEnum(sipRes,sipType_tlp_ProgressState);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_state, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_getError, "tlp.PluginProgress.getError()\n"
    "\n"
    "Returns a message describing the error encountered during the process. \n"
    "If no error has been encountered, an empty string is returned.\n"
    "\n"
    ":rtype: string");

extern "C" {static PyObject *meth_tlp_PluginProgress_getError(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_getError(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_tlp_PluginProgress, &sipCpp))
        {
            std::string *sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_getError);
                return NULL;
            }

            sipRes = new std::string(sipCpp->getError());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_getError, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_setError, "tlp.PluginProgress.setError(errorMsg)\n"
    "\n"
    "Sets the message describing the error encountered during the process.\n"
    "\n"
    ":param errorMsg: the error message to set\n"
    ":type errorMsg: string");

extern "C" {static PyObject *meth_tlp_PluginProgress_setError(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_setError(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        std::string * a0;
        int a0State = 0;
        tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_PluginProgress, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_setError);
                return NULL;
            }

            sipCpp->setError(*a0);
            sipReleaseType(a0,sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_setError, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_PluginProgress_setComment, "tlp.PluginProgress.setComment(msg)\n"
    "\n"
    "Changes the comment about the process progression.\n"
    "\n"
    ":param msg: A description of what the process is currently doing, displayed to inform the user.\n"
    ":type msg: string");

extern "C" {static PyObject *meth_tlp_PluginProgress_setComment(PyObject *, PyObject *);}
static PyObject *meth_tlp_PluginProgress_setComment(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        std::string * a0;
        int a0State = 0;
        tlp::PluginProgress *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_tlp_PluginProgress, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_PluginProgress, sipName_setComment);
                return NULL;
            }

            sipCpp->setComment(*a0);
            sipReleaseType(a0,sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_PluginProgress, sipName_setComment, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_tlp_PluginProgress(void *, const sipTypeDef *);}
static void *cast_tlp_PluginProgress(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_tlp_PluginProgress)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_tlp_PluginProgress(void *, int);}
static void release_tlp_PluginProgress(void *sipCppV,int)
{
    delete reinterpret_cast<tlp::PluginProgress *>(sipCppV);
}


extern "C" {static void dealloc_tlp_PluginProgress(sipSimpleWrapper *);}
static void dealloc_tlp_PluginProgress(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_tlp_PluginProgress(sipGetAddress(sipSelf),0);
    }
}


static PyMethodDef methods_tlp_PluginProgress[] = {
    {SIP_MLNAME_CAST(sipName_cancel), meth_tlp_PluginProgress_cancel, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_cancel)},
    {SIP_MLNAME_CAST(sipName_getError), meth_tlp_PluginProgress_getError, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_getError)},
    {SIP_MLNAME_CAST(sipName_isPreviewMode), meth_tlp_PluginProgress_isPreviewMode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_isPreviewMode)},
    {SIP_MLNAME_CAST(sipName_progress), meth_tlp_PluginProgress_progress, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_progress)},
    {SIP_MLNAME_CAST(sipName_setComment), meth_tlp_PluginProgress_setComment, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_setComment)},
    {SIP_MLNAME_CAST(sipName_setError), meth_tlp_PluginProgress_setError, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_setError)},
    {SIP_MLNAME_CAST(sipName_setPreviewMode), meth_tlp_PluginProgress_setPreviewMode, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_setPreviewMode)},
    {SIP_MLNAME_CAST(sipName_showPreview), meth_tlp_PluginProgress_showPreview, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_showPreview)},
    {SIP_MLNAME_CAST(sipName_state), meth_tlp_PluginProgress_state, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_state)},
    {SIP_MLNAME_CAST(sipName_stop), meth_tlp_PluginProgress_stop, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_PluginProgress_stop)}
};

PyDoc_STRVAR(doc_tlp_PluginProgress, "This interface allows to notify and control the progression of a process.");


sipClassTypeDef sipTypeDef_tulip_tlp_PluginProgress = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_tlp__PluginProgress,
        {0}
    },
    {
        sipNameNr_PluginProgress,
        {21, 255, 0},
        10, methods_tlp_PluginProgress,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_tlp_PluginProgress,
    -1,
    -1,
    0,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_tlp_PluginProgress,
    0,
    0,
    0,
    release_tlp_PluginProgress,
    cast_tlp_PluginProgress,
    0,
    0,
    0
};

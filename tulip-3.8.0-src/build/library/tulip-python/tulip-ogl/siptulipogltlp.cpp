/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.13.2 on Mon Apr 29 01:50:53 2013
 */

#include "sipAPItulipogl.h"


#line 30 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip-ogl/../tulip/Color.sip"
#include <tulip/Color.h>
#line 13 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip-ogl/siptulipogltlp.cpp"
#line 37 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip-ogl/../tulip/../stl/vector.sip"
#include <vector>
#line 16 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip-ogl/siptulipogltlp.cpp"
#line 191 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip-ogl/../tulip/../stl/vector.sip"
#include <vector>
#line 19 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip-ogl/siptulipogltlp.cpp"
#line 33 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip-ogl/../tulip/Coord.sip"
#include <tulip/Coord.h>
#line 22 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip-ogl/siptulipogltlp.cpp"
#line 37 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/library/tulip-python/tulip-ogl/../tulip/../stl/vector.sip"
#include <vector>
#line 25 "/home/kirbybanman/browseRDF/tulip-3.8.0-src/build/library/tulip-python/tulip-ogl/siptulipogltlp.cpp"


PyDoc_STRVAR(doc_tlp_computeOpenUniformBsplinePoints, "tlp.computeOpenUniformBsplinePoints(list-of-tlp.Coord, int curveDegree=3, int nbCurvePoints=100) -> list-of-tlp.Coord");

extern "C" {static PyObject *meth_tlp_computeOpenUniformBsplinePoints(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeOpenUniformBsplinePoints(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<tlp::Coord> * a0;
        int a0State = 0;
        std::vector<tlp::Coord> * a1;
        uint a2 = 3;
        uint a3 = 100;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|uu", sipType_std_vector_0100tlp_Coord,&a0, &a0State, &a2, &a3))
        {
            a1 = new std::vector<tlp::Coord>();

            tlp::computeOpenUniformBsplinePoints(*a0,*a1,a2,a3);
            sipReleaseType(const_cast<std::vector<tlp::Coord> *>(a0),sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(a1,sipType_std_vector_0100tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeOpenUniformBsplinePoints, doc_tlp_computeOpenUniformBsplinePoints);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeOpenUniformBsplinePoint, "tlp.computeOpenUniformBsplinePoint(list-of-tlp.Coord, float, int curveDegree=3) -> tlp.Coord");

extern "C" {static PyObject *meth_tlp_computeOpenUniformBsplinePoint(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeOpenUniformBsplinePoint(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<tlp::Coord> * a0;
        int a0State = 0;
        float a1;
        uint a2 = 3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1f|u", sipType_std_vector_0100tlp_Coord,&a0, &a0State, &a1, &a2))
        {
            tlp::Coord *sipRes;

            sipRes = new tlp::Coord(tlp::computeOpenUniformBsplinePoint(*a0,a1,a2));
            sipReleaseType(const_cast<std::vector<tlp::Coord> *>(a0),sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(sipRes,sipType_tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeOpenUniformBsplinePoint, doc_tlp_computeOpenUniformBsplinePoint);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeCatmullRomPoints, "tlp.computeCatmullRomPoints(list-of-tlp.Coord, bool closedCurve=False, int nbCurvePoints=100, float alpha=0.5) -> list-of-tlp.Coord");

extern "C" {static PyObject *meth_tlp_computeCatmullRomPoints(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeCatmullRomPoints(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<tlp::Coord> * a0;
        int a0State = 0;
        std::vector<tlp::Coord> * a1;
        bool a2 = 0;
        uint a3 = 100;
        float a4 = 0.5;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|buf", sipType_std_vector_0100tlp_Coord,&a0, &a0State, &a2, &a3, &a4))
        {
            a1 = new std::vector<tlp::Coord>();

            tlp::computeCatmullRomPoints(*a0,*a1,a2,a3,a4);
            sipReleaseType(const_cast<std::vector<tlp::Coord> *>(a0),sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(a1,sipType_std_vector_0100tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeCatmullRomPoints, doc_tlp_computeCatmullRomPoints);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeCatmullRomPoint, "tlp.computeCatmullRomPoint(list-of-tlp.Coord, float, bool closedCurve=False, float alpha=0.5) -> tlp.Coord");

extern "C" {static PyObject *meth_tlp_computeCatmullRomPoint(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeCatmullRomPoint(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<tlp::Coord> * a0;
        int a0State = 0;
        float a1;
        bool a2 = 0;
        float a3 = 0.5;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1f|bf", sipType_std_vector_0100tlp_Coord,&a0, &a0State, &a1, &a2, &a3))
        {
            tlp::Coord *sipRes;

            sipRes = new tlp::Coord(tlp::computeCatmullRomPoint(*a0,a1,a2,a3));
            sipReleaseType(const_cast<std::vector<tlp::Coord> *>(a0),sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(sipRes,sipType_tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeCatmullRomPoint, doc_tlp_computeCatmullRomPoint);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeBezierPoints, "tlp.computeBezierPoints(list-of-tlp.Coord, int nbCurvePoints=100) -> list-of-tlp.Coord");

extern "C" {static PyObject *meth_tlp_computeBezierPoints(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeBezierPoints(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<tlp::Coord> * a0;
        int a0State = 0;
        std::vector<tlp::Coord> * a1;
        uint a2 = 100;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|u", sipType_std_vector_0100tlp_Coord,&a0, &a0State, &a2))
        {
            a1 = new std::vector<tlp::Coord>();

            tlp::computeBezierPoints(*a0,*a1,a2);
            sipReleaseType(const_cast<std::vector<tlp::Coord> *>(a0),sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(a1,sipType_std_vector_0100tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeBezierPoints, doc_tlp_computeBezierPoints);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_computeBezierPoint, "tlp.computeBezierPoint(list-of-tlp.Coord, float) -> tlp.Coord");

extern "C" {static PyObject *meth_tlp_computeBezierPoint(PyObject *, PyObject *);}
static PyObject *meth_tlp_computeBezierPoint(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<tlp::Coord> * a0;
        int a0State = 0;
        float a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1f", sipType_std_vector_0100tlp_Coord,&a0, &a0State, &a1))
        {
            tlp::Coord *sipRes;

            sipRes = new tlp::Coord(tlp::computeBezierPoint(*a0,a1));
            sipReleaseType(const_cast<std::vector<tlp::Coord> *>(a0),sipType_std_vector_0100tlp_Coord,a0State);

            return sipConvertFromNewType(sipRes,sipType_tlp_Coord,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_computeBezierPoint, doc_tlp_computeBezierPoint);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_buildPascalTriangle, "tlp.buildPascalTriangle(int) -> list-of-std_vector_2400");

extern "C" {static PyObject *meth_tlp_buildPascalTriangle(PyObject *, PyObject *);}
static PyObject *meth_tlp_buildPascalTriangle(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        std::vector<std_vector_2400> * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "u", &a0))
        {
            a1 = new std::vector<std_vector_2400>();

            tlp::buildPascalTriangle(a0,*a1);

            return sipConvertFromNewType(a1,sipType_std_vector_0100std_vector_2400,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_buildPascalTriangle, doc_tlp_buildPascalTriangle);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_setMaterial, "tlp.setMaterial(tlp.Color)");

extern "C" {static PyObject *meth_tlp_setMaterial(PyObject *, PyObject *);}
static PyObject *meth_tlp_setMaterial(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Color * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_tlp_Color, &a0))
        {
            tlp::setMaterial(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_setMaterial, doc_tlp_setMaterial);

    return NULL;
}


PyDoc_STRVAR(doc_tlp_setColor, "tlp.setColor(tlp.Color)");

extern "C" {static PyObject *meth_tlp_setColor(PyObject *, PyObject *);}
static PyObject *meth_tlp_setColor(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const tlp::Color * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_tlp_Color, &a0))
        {
            tlp::setColor(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_setColor, doc_tlp_setColor);

    return NULL;
}


static PyMethodDef methods_tlp[] = {
    {SIP_MLNAME_CAST(sipName_buildPascalTriangle), meth_tlp_buildPascalTriangle, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_buildPascalTriangle)},
    {SIP_MLNAME_CAST(sipName_computeBezierPoint), meth_tlp_computeBezierPoint, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeBezierPoint)},
    {SIP_MLNAME_CAST(sipName_computeBezierPoints), meth_tlp_computeBezierPoints, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeBezierPoints)},
    {SIP_MLNAME_CAST(sipName_computeCatmullRomPoint), meth_tlp_computeCatmullRomPoint, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeCatmullRomPoint)},
    {SIP_MLNAME_CAST(sipName_computeCatmullRomPoints), meth_tlp_computeCatmullRomPoints, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeCatmullRomPoints)},
    {SIP_MLNAME_CAST(sipName_computeOpenUniformBsplinePoint), meth_tlp_computeOpenUniformBsplinePoint, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeOpenUniformBsplinePoint)},
    {SIP_MLNAME_CAST(sipName_computeOpenUniformBsplinePoints), meth_tlp_computeOpenUniformBsplinePoints, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_computeOpenUniformBsplinePoints)},
    {SIP_MLNAME_CAST(sipName_setColor), meth_tlp_setColor, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_setColor)},
    {SIP_MLNAME_CAST(sipName_setMaterial), meth_tlp_setMaterial, METH_VARARGS, SIP_MLDOC_CAST(doc_tlp_setMaterial)}
};


sipClassTypeDef sipTypeDef_tulipogl_tlp = {
    {
        -1,
        0,
        0,
        SIP_TYPE_NAMESPACE,
        sipNameNr_tlp,
        {0}
    },
    {
        sipNameNr_tlp,
        {0, 0, 1},
        9, methods_tlp,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    0,
    -1,
    -1,
    0,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
